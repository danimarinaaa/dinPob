[
["index.html", "Ecología de poblaciones silvestres Capítulo 1 Introducción", " Ecología de poblaciones silvestres David Martínez Cascante 2018-04-04 Capítulo 1 Introducción La ecología de poblaciones se centra en el estudio de la dinámica de las poblaciones (su crecimiento e interacción con otras poblaciones), y en las interacciones de éstas con el ambiente. La ecología de poblaciones (también llamada dinámica de poblaciones) es un campo con un componente matemático y estadístico fuerte, y de gran importancia para la gestión de vida silvestre. Algunas de las aplicaciones más importantes de esta disciplina, están relacionadas al cálculo de la viabilidad de poblaciones, al cálculo de tasas de extracción, e incluso a la creación de áreas protegidas dedicadas a proteger el ciclo de vida, o parte de éste, en determinadas especies. El Análisis de Viabilidad de Poblaciones, es un ejemplo de una de las aplicaciones de la ecología de poblaciones para la gestión de vida silvestre. Este modelo predice el riesgo de que una población se extinga en una determinada cantidad de años. De esta manera, los gestores pueden modelar diferentes escenarios, cada cual con un conjunto específico de acciones de manejo, y decidir cuál de éstos es más efectivo en la conservación o manejo de la especie. La creación de santuarios de pesca, por ejemplo, se fundamenta en el concepto de Biogeografía de Islas (REF) que también es parte de la ecología de poblaciones. Los santuarios de pesca funcionan como fuentes, es decir, zonas donde el crecimiento poblacional es positivo y existe migración de individuos. Éstos individuos, que se producen en exceso, migrarán hacia zonas de pesca, o extracción, para sostener actividades económicas. De esta manera, se garantiza la extracción sostenible en las zonas aledañas. Algunos modelos importantes, como el modelo bioeconómico, que buscan la mayor rentabilidad económica por la extracción de una especie (Grafton et al. 2006), están basados en modelos de crecimiento derivados de la dinámica de poblaciones. Este modelo estima la cantidad de esfuerzo extractivo que debe aplicarse a una especie, para mantener una rentabilidad positiva, y mantener un tamaño poblacional que garantice la continuidad de las poblaciones aprovechadas. La dinámica de poblaciones es una de las ramas de la biología con un componente matemático y estadístico más fuertes. El desarrollo teórico de los modelos implica conocimiento de planteamiento y resolución de ecuaciones diferenciales. En la práctica, muchos problemas se plantean como ecuaciones diferenciales, pero no tienen solución analítica, por lo cual se requiere de conocimiento sobre métodos numéricos, programación o uso de lenguajes de programación. La mayoría de profesionales, no son desarrolladores teóricos, pero deben saber, al menos, sobre el uso de herramientas de análisis para esta disciplina. Si el investigador conoce las herramientas de análisis, y quiere ponerlas en práctica, entonces requiere de conocimientos en diseño experimental y muestreal; así como, técnicas de muestreo para conseguir los datos. Pero la limitación más fuerte, es el financiamiento requerido; ya que, la mayoría de los análisis tienen fuertes requerimientos de datos, y series de tiempo bastante amplias. References "],
["modelos-de-crecimiento.html", "Capítulo 2 Modelos de crecimiento 2.1 Crecimiento denso-independiente 2.2 Crecimiento denso-dependiente 2.3 Otras fuentes bibliográficas", " Capítulo 2 Modelos de crecimiento HACER: conceptos de producción en exceso, de Darwin, y lucha por la existencia. La evolución por selección natural implica que en una población que enfrente presiones para subsistir, existirán individuos mejor adaptados que otros. Algunos vivirán lo suficiente para reproducirse y otros no; además, dentro de aquellos que se reproduzcan, los más exitosos lo harán más frecuentemente, o con mayor descendencia. Este concepto implica que en una población debe haber suficiente variabilidad genética, que se refleje en un desempeño diferente en la reproducción, y que no todos los organismos vivirán lo suficiente para dejar descendencia o reemplazarse a sí mismos. Esto quiere decir, que las poblaciones deben de reproducirse y dejar un exceso de decendencia, para poder amortiguar el efecto sobre la reproducción de aquellos organismos que no logren reproducirse con éxito. De esta manera, la sobre-producción de organismos es un requisito para que una población subsista en un intervalo prolongado de tiempo. Y la sobre-producción implica que las poblaciones tienen el potencial de crecer. La disciplina de la ecología de poblaciones, entonces, ha enfocado esfuerzos en modelar el crecimiento poblacional usando funciones matemáticas. Veremos las más básicas de ellas, con el objetivo de entender el origen y desarrollo de estos modelos. El crecimiento en dinámica de poblaciones, está enfocado en la población, y no en el individuo. Algunos aspectos fisiológicos, e individuales, pueden ser importantes a la hora de modelar el crecimiento poblacional, y estos pueden ser incluidos como parámetros del modelo; pero, en general, el interés se centra en la estimación de la cantidad de individuos (o la biomasa) que conforma una población, y cómo cambia esta cantidad con respecto al tiempo. El objetivo de los modelos de crecimiento, es obtener una función del tamaño de la población con respecto al tiempo. Existen dos aproximaciones principales para obtener esta función: la exponencial y la geométrica. El crecimiento exponencial se mide en cualquier momento en el tiempo, mientras que el crecimiento geométrico se mide a intervalos discretos. Es decir, ambos miden el crecimiento poblacional, pero una aproximación lo hace en intervalos continuos y la otra en intervalos discretos. Las otra gran categoría de modelos de crecimiento tienen que ver con la dependencia de la densidad de población. Por ejemplo, una población con suficiente espacio y recursos, puede considerarse denso-independiente, mientras que una población que está en permanente competencia intraespecífica por la adquisición de espacio y recursos, tiene un crecimiento denso-dependiente. 2.1 Crecimiento denso-independiente 2.1.1 Crecimiento geométrico Nuestra variable de interés es el tamaño poblacional, \\(N\\). Queremos conocer el crecimiento poblacional desde año 0 (\\(t=0\\)) hasta el año 1 (\\(t=1\\)). Entonces, podemos restar \\(N_1 - N_0\\) para encontrar dicho crecimiento, al que llamaremos \\(\\Delta N\\) (“Delta N”). De manera similar, podemos encontrar el crecimiento de la población en cualquier sub-intervalo de tiempo. Por ejemplo, si queremos conocer el crecimiento en el periodo \\(t=1\\) y \\(t=0.5\\), entonces nombramos este intervalo como \\(\\Delta t\\), y obtenemos el dato al dividir \\(\\Delta N / \\Delta t\\). Esta razón corresponde a la tasa de crecimiento. Una primer idea de cómo modelar la tasa de crecimiento, es pensar en que ésta equivale a la diferencia entre las entradas a la población (\\(B\\), natalidad e inmigración) menos las salidas de la población (\\(D\\), mortalidad y emigración): \\[ \\frac{\\Delta N}{\\Delta t} = B-D \\] Para conocer la tasa de crecimiento per cápita, dividimos la ecuación anterior por \\(N\\): \\[ \\frac{\\frac{\\Delta N}{\\Delta t}}{N} = \\frac{D-B}{N} \\] Si la tasa de crecimiento per cápita es mayor a cero, entonces la población crece. Si es igual a cero, la población se mantiene estable. Si es menor a cero, la población decrece. Si asumimos que la diferencia entra las entradas de la población y sus salidas son constantes, podemos arreglar la expresión anterior como \\(\\frac{E-S}{N}=\\mathrm{R_m}\\); con lo que obtenemos la forma familiar de la tasa de crecimiento: \\[\\begin{equation} \\frac{\\Delta N}{\\Delta t}=\\mathrm{R_m} N \\tag{2.1} \\end{equation}\\] Sin embargo, la ecuación (2.1) aún no está en función del tiempo, que es el objetivo que se busca. Primero empecemos por predecir La población en el año uno (\\(N_1\\)) en función del tamaño de población inicial (\\(N_0\\)). Sabemos que \\(N_1\\) será igual a \\(N_0\\) más el crecimiento poblacional durante ese intervalo de tiempo. Es decir: \\[ N_1 = N_0 + \\frac{\\Delta N}{\\Delta t} \\] Y por la ecuación (2.1), substituyendo \\(N = N_0\\), se tiene la relación: \\[\\begin{equation} \\begin{split} N_1 &amp;= N_0 + \\mathrm{R_m} N_0\\\\ &amp;= N_0 \\left( 1 + \\mathrm{R_m} \\right)\\\\ &amp;= N_0 \\lambda\\\\ \\end{split} \\end{equation}\\] Por tanto, el tamaño de población en el año uno, es igual al tamaño de población en el año cero, más el producto de la tasa de crecimiento per cápita por el tamaño de población en el año cero. Los arreglos posteriores, muestran que \\(N_1\\) depende de \\(N_0\\) y una constante \\(\\lambda = 1+\\mathrm{R_m}\\), la cual representa la tasa de multiplicación. Entonces, la población crece cuando \\(\\lambda &gt; 1\\), se mantiene estable si \\(\\lambda = 1\\), y decrece si \\(\\lambda &lt; 1\\). Ahora, podemos obtener \\(N_2\\) al saber que \\(N_2 = N_1 \\lambda\\). Observamos que \\(N_1 = N_0 \\lambda\\); por tanto, sustituimos el valor de \\(N_1\\) para acabar con \\(N_2 = N_0 \\lambda \\lambda = N_0 \\lambda^2\\). Si proseguimos de esta manera, concluimos que: \\[\\begin{equation} N_t = N_0 \\lambda^t \\tag{2.2} \\end{equation}\\] Con lo que finalmente se logra el objetivo de tener una función del tamaño poblacional en relación al tiempo. 2.1.1.1 Ejemplos Example 2.1 Graficar la ecuación (2.2) Ahora que tenemos una relación del tamaño poblacional con el tiempo, podemos crear una función sencilla para observar su comportamiento. plotGeomGrowth &lt;- function(N0, lambda, t){ vectorTiempo &lt;- 0:t vectorPoblacion &lt;- N0*lambda^vectorTiempo plot(vectorTiempo, vectorPoblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(vectorTiempo, vectorPoblacion) } plotGeomGrowth(50, 1.1, 10) Example 2.2 ¿Cuál es el \\(\\lambda\\) de una población que cuenta con 33 individuos en el año 0 (\\(t=0\\)), y que tras 10 años cuenta con 25 individuos? Grafique la curva de crecimiento. Al despejar la ecuación (2.2) para \\(\\lambda\\) se tiene \\[ \\lambda = \\left( \\frac{N_t}{N_0} \\right)^\\frac{1}{t} \\] Substituyendo los valores correspondientes se tiene que \\(\\lambda =\\) . Luego, usando la función creada en el ejemplo 2.1, y el recién calculado lambda, se grafica la curva de crecimiento. 2.1.1.2 Ejercicios Exercise 2.1 Grafique la ecuación (2.1). En el eje y la tasa de crecimiento y en el eje x el tamaño poblacional. Utilice tres valores de \\(\\mathrm{R_m}\\), uno positivo, uno igual a cero y otro negativo. El tamaño inicial de la población es de 50 individuos. \\(\\mathrm{R_m} \\in \\left[ -1, 1 \\right]\\), y \\(N \\in \\left[ 0, 50 \\right]\\). Cuál es la representación gráfica de \\(\\mathrm{R_m}\\) en el gráfico. Exercise 2.2 Grafique la ecuación (2.2). Utilice tres valores de \\(\\lambda\\), uno mayor a uno, otro igual a uno, y el último menor a 1, pero mayor a cero. El tamaño inicial de la población es de 50 individuos. Exercise 2.3 PICANTE Todo libro de lógica matemática debe contener los métodos de demostración más comunes. Utilice el metodo de inducción matemática para demostrar que la ecuación (2.2) es válida para todo \\(n \\in \\mathbb{N}\\) (números naturales). 5% sobre la nota, dividido entre el número de estudiantes que respondan el ejericio. Exercise 2.4 Si inoculo una población de bacterias en un medio de cultivo con suficiente espacio y nutrientes, con un estimado de , y tras tres horas, se estima una población de , ¿Qué valor tiene lambda? NOTA. En este caso, \\(t\\) representa una hora. Exercise 2.5 Un cultivo de células dobla su tamaño poblacional en 15 minutos (\\(\\lambda = 2\\)). Si se empieza con 1000 células, ¿cuántas de ellas existen tras 3 horas? 2.1.2 Crecimiento exponencial En la sección anterior, se trabajó con intervalos de tiempo discretos. Pero si queremos conocer el tamaño poblacional en cualquier momento del tiempo, debemos trabajar con intervalos infinitamente pequeños. Esto quiere decir que la ecuación (2.2) se escribe en su forma continua: \\[\\begin{equation} \\frac{dN}{dt}=\\mathrm{r_m} N \\tag{2.3} \\end{equation}\\] La ecuación (2.3) es una ecuación diferencial de primer orden. Este tipo particular de ecuaciones diferenciales tienen una solución analítica. Para este caso, se puede utilizar el método de separación de variables, para obtener la siguiente expresión del tamaño poblacional con respecto al tiempo (ver ejemplo 2.3): \\[\\begin{equation} N_t=N_0 e^{\\mathrm{r_m}t} \\tag{2.4} \\end{equation}\\] En la expresión anterior, \\(\\mathrm{r_m}\\) es la tasa instantánea de crecimiento, también conocida como la tasa intrínseca de crecimiento natural, o el parámetro de Malthus por Thomas Malthus. Este parámetro equivale a la diferencia entre la tasa intrínseca de nacimiento y la tasa intrínseca de mortalidad (\\(b - d\\)). La tasa intrínseca está relacionada con la tasa de multiplicación de la siguiente forma: \\[\\begin{equation*} \\begin{split} \\lambda &amp;= e^{\\mathrm{r_m}}\\\\ \\mathrm{r_m} &amp;= \\ln\\lambda\\\\ \\end{split} \\end{equation*}\\] El parámetro \\(\\mathrm{r_m}\\) tiene aplicaciones interesantes. Una de ellas es su facilidad para utilizarse en diferentes escalas de tiempo. Por ejemplo, si \\(\\mathrm{r_m} = 0.1\\) por día, y queremos escalarlo a escala semanal, procedemos a multiplicar \\(\\mathrm{r_m} = 0.1 \\times 7 = 0.7\\). Al hacer esta transformación, se debe tener en cuenta la escala de tiempo con la que se interpretan y presentan los resultados. 2.1.2.1 Ejemplos Example 2.3 Como obtener la ecuación de crecimiento exponencial (2.4) de la ecuación diferencial (2.3). El método de separación de variables consiste en dejar todos los términos de la incógnita de un lado, y los términos de la variable independiente (\\(t\\)) del otro lado de la igualdad (Barrantes Campos 2015). Entonces: \\[ \\frac{1}{N} \\times \\frac{dN}{dt}=\\mathrm{r_m} \\] Luego se integra ambos lados con respecto de la variable independiente: \\[ \\int \\left( \\frac{1}{N} \\times \\frac{dN}{dt}\\right)\\,dt=\\int \\mathrm{r_m}\\,dt \\] Observe que del lado izquierdo los diferenciales se cancelan: \\[\\begin{equation*} \\begin{split} \\int \\frac{dN}{N}&amp;=\\mathrm{r_m} t + c\\\\ \\ln N &amp; = \\mathrm{r_m} t + c\\\\ \\end{split} \\end{equation*}\\] Se despeja \\(N\\), y se obtiene \\(N=Ce^{\\mathrm{r_m} t}\\). Luego, cuando \\(N=N_0\\) entonces \\(t=0\\); por lo que la expresión se simplifica a \\(N_0 = C e^0 = C\\). Dando como resultado la expresión \\[ N = N_0 e^{\\mathrm{r_m} t} \\] Example 2.4 De acuerdo con Illman, Scragg, and Shales (2000) un gramo de Chlorella emersonii puede contener (energía por gramo). Si la tasa intrínseca es de , ¿cuántos gramos de Chlorella necesito para producir ? ¿Cuál es el tiempo de producción? Asuma un crecimiento exponencial, y un inóculo inicial con \\(N_0 = 1\\mu \\si{\\gram}\\) de Chlorella. En este caso, pensamos en el tamaño poblacional como biomasa, en lugar del número de individuos. El primer paso es calcular \\(N\\) para producir la cantidad deseada de energía, lo cual resolvemos con una simple conversión para obtener: \\[ N=\\frac{1\\si{\\gram}}{29\\cancel{\\si{\\kilo\\joule}}}\\times 5000 \\cancel{\\si{\\kilo\\joule}}=172.4138\\si{\\gram} \\] Luego, despejamos \\(t\\) de la ecuación (2.4): \\[ t = \\ln \\left(\\frac{N}{N_0}\\right)\\mathrm{r_m}^{-1} \\] Se hacen las sustituciones correspondientes: \\(\\mathrm{r_m} = 0.99\\), \\(N_0 = \\SI{1e-6}{\\gram}\\), \\(N = \\SI{172.414}{\\gram}\\), y se obtiene que el tiempo necesario para obtener una biomasa equivalente a una energía de 5000 kilojoule es \\(t =\\) . 2.1.2.2 Ejercicios Exercise 2.6 Si \\(\\lambda = 1.027\\) por semana. Escale \\(\\lambda\\) de semanas a meses (1 mes = 4 semanas). Utilice la relación de \\(\\lambda = e^{\\mathrm{r_m}}\\). Exercise 2.7 Para los siguentes escenarios de la ecuación (2.4): \\(\\mathrm{r_m}\\) negativo. \\(\\mathrm{r_m}\\) igual a cero. \\(\\mathrm{r_m}\\) positivo. Obtenga el límite: \\[ \\lim_{t \\to \\infty } N(t) \\] Dé una interpretación de los resultados, en términos de la población. Exercise 2.8 Demuestre, utilizando un razonamiento deductivo, que si \\(\\mathrm{R_m} &lt; 0\\), la población decrece. Puede usar los resultados del ejercicio 2.7. Exercise 2.9 Analice biológicamente el significado del resultado del ejercicio 2.7, cuando \\(\\mathrm{r_m}\\) es positivo. 2.2 Crecimiento denso-dependiente 2.2.1 Crecimiento logístico Nuestros dos modelos básicos funcionan en condiciones controladas, cuando el espacio y los recursos no son limitantes para el crecimiento. Sin embargo, esto no es lo que se observa en poblaciones silvestres, donde tras el periodo de crecimiento exponencial, sigue una disminución en la velocidad del crecimiento, hasta que llega a ser cero, o incluso negativo (decrecimiento). Pueden existir varios mecanismos de regulación del crecimiento. Entre ellos existe la competencia intraespecífica, la competencia interespecífica, la depredación, entre otros. Algunas razones para la desaceleración del crecimiento pueden estar relacionadas a la tasa de consumo de alimento, frente a la tasa de producción. En este caso, cuando la tasa de consumo iguala a la tasa de producción, la población pierde el potencial de crecer. Los individuos empiezan a competir, puede haber emigración, mortalidad, etc. Independientemente de las razones que causen la disminución del crecimiento, podemos entender que la tasa intrínseca de crecimiento (\\(r_m\\)), en realidad no es una constante como en el modelo de crecimiento exponencial (Figura ??); más bien, es una función del tamaño de población, \\(N\\) (Figura ??). \\[ r_m = f \\left( N_t \\right) \\] Esta función debe tener algunas características particulares. Por ejemplo, debe ser máxima cuando el tamaño de población es pequeño, asumiendo que en ese momento hay muchos recursos y espacio para todos los individuos. Por otro lado, cuando la población alcanza un tamaño grande, la tasa de crecimiento debe disminuir hasta llegar a cero. Debemos introducir un nuevo término a nuestro modelo de crecimiento, para cumplir con las características descritas arriba. Este término es la capacidad de carga, \\(K\\), que es el punto donde la tasa de crecimiento se vuelve cero. Una expresión que cumple con estos requerimientos es: \\[ r_m = \\mathrm{r_m}\\left(1-\\frac{N_t}{K}\\right) \\] Podemos observar el comportamiento de \\(r_m\\) con un gráfico: rm &lt;- 1 K &lt;- 100 N &lt;- 0:100 val &lt;- rm * (1 - (N / K)) plot(N, val, type = &quot;l&quot;, las = 1, lwd = 2, xlab = &quot;Tamaño de población&quot;, ylab = expression(r[m]) ) Si ahora sustituimos la versión denso-dependiente de \\(r_m\\) en la ecuación (2.4), obtenemos \\[\\begin{equation} \\frac{dN}{dt}=\\mathrm{r_m} N_t \\left(1-\\frac{N_t}{K}\\right) \\tag{2.5} \\end{equation}\\] Esta ecuación diferencial también puede resolverse por el método de separación de variables (ver Ejemplo 2.3). Una vez resuelta, la expresión en función del tiempo es: \\[\\begin{equation} N_t= \\frac{K}{1+\\left(\\frac{K}{N_0}-1\\right)e^{-rt}} \\tag{2.6} \\end{equation}\\] Podemos graficar el comportamiento de la curva para una población hipotética con: \\(\\mathrm{r_m} = 0.4\\), \\(K = 100\\), y \\(N_0 = 10\\). Para ello, usamos el siguiente código: r &lt;- 0.4 K &lt;- 100 N0 &lt;- 10 curve( K/(1+((K/N0-1)*exp(-r*x))), from = 0,to = 20, las = 1, lwd = 2, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de Población&quot;) Figure 2.1: Crecimiento logístico, con capacidad de carga igual a cien individuos Observamos que la población ya no crece de manera indefinida. Ahora tiene un tope superior igual a la capacidad de carga, \\(K\\). Técnicamente, decimos que existe un límite asintótico al crecimiento; ya que, el tamaño de población tiende a \\(K\\), pero nunca llega a alcanzarlo (pero ver ejercicio 2.10). Por otro lado, observamos que la población crece rápidamente al inicio; pero, al final de la curva el crecimiento se detiene. Esto implica que en algún punto, el crecimiento alcanza un máximo. Este punto se conoce como el punto de inflexión. De cálculo diferencial, sabemos que los puntos de inflexión se obtienen al igualar la segunda derivada de la función a cero: \\[ \\frac{d^2N}{dt^2}=\\frac{d(dN)}{d(dt)}=0 \\] Sabemos que la primer derivada de \\(N_t\\) corresponde a la ecuación (2.5). Entonces, para encontrar el punto de inflexión, primero debemos encontrar: \\[ \\frac{d^2N}{dt^2}=\\frac{d(dN)}{d(dt)}=D\\left[ \\mathrm{r_m}N_t\\left(1-\\frac{N_t}{K}\\right)\\right]=0 \\] Se utiliza la regla del producto, y se tiene: \\[ D_{N_t}\\left[ \\mathrm{r_m}N_t \\right]\\left(1-\\frac{N_t}{K}\\right) + \\mathrm{r_m}N_t\\; D_{N_t}\\left[\\left(1-\\frac{N_t}{K}\\right)\\right]=0 \\] Al resolver las derivadas se obtiene: \\[ N = \\frac{K}{2} \\] Quiere decir, que el mayor crecimiento se obtiene cuando el tamaño de población es igual a la mitad de la capacidad de carga. Si sustituimos \\(N = K/2\\) en la ecuación (2.5), tenemos que el crecimiento máximo de una población es: \\[ \\left. \\frac{dN}{dt}\\right|_{N = K/2} = \\frac{\\mathrm{r_m}K}{4} \\] Esto tiene grandes implicaciones en el manejo de recursos naturales. Es la base de los modelos de producción excedentaria. En pesquerías, a este número se le conoce como Máximo Rendimiento Sostenible; sin embargo, ha sido fuertemente criticado (Larkin 1977), y en la actualidad se utilizan algunas variantes de esta cantidad, o otros modelos más apropiados, basados en estructura de edades o tallas. 2.2.2 Usos del modelo logístico En la sección anterior calculamos el Máximo Rendimiento Sostenible (MRS). Ahora lo definiremos como: El crecimiento máxmimo que una población puede producir, bajo una capacidad de carga determinada. Ésta es la cantidad máxima de individuos, o biomasa, que se puede extraer de una población, sin provocar un crecimiento negativo. Recordando que: Tamaño de población = Tamaño anterior + Crecimiento La idea de cosechar una población se fundamenta en que si se extrae una cantidad igual al crecimiento de la población, la biomasa restante logrará regenerarse y crecer. La idea del MRS, es que el tamaño de una población cosechada, debe llevarse a \\(N/2\\), para poder aprovechar el crecimiento máximo que puede generar dicha población. Exercise 2.10 Demuestre que la población no crecerá más cuando llega a la capacidad de carga. Es decir, tome el límite de la ecuación (2.5), cuando \\(t \\to \\infty\\). Exercise 2.11 Suponga que existe un tanque sobre una balanza. Este tanque contiene aguas residuales, que son limpiadas por una pequeña planta del genero Lemna. El flujo del tanque es tal, que la masa del agua siempre se mantiene constante; de modo que la balanza solo mide el crecimiento de Lemna. Nos interesa mantener una población de Lemna con un rápido crecimiento; ya que éste es proporcional a la tasa de extracción de toxinas del tanque. El tanque inicia con de Lemna, con una tasa de crecimiento es de . Además, se ha determinado que el tanque solo soporta de Lemna. ¿Cuál es el tamaño de población de Lemna que debería haber en el tanque para maximizar el crecimiento? ¿Cuánta biomasa debe extraer en un día para mantener un máximo de crecimiento? ¿A qué biomasa total debería cosechar la Lemna? Exercise 2.12 De acuerdo con la definición del MRS, se asume que el crecimiento es igual a la cosecha. ¿Qué tan atinada es esta suposición? Exercise 2.13 Grafique la tasa de crecimiento poblacional usando \\(N_t\\) como variable independiente. Asuma \\(K=100\\), \\(N_0=1\\), \\(r_m=1\\). 2.2.3 Matrices COMADRE COMADRE DATA Ojo a la guia de usuario 2.3 Otras fuentes bibliográficas Esta sección está basada en los capítulos 4 y 5 de Neal (2004). En la sección 2.3 de Berryman and Kindlmann (2008), se desarrollan los mismos modelos básicos vistos aquí; en este mismo libro se presenta una buena introducción sobre la ecología de poblaciones como sistemas, en el capítulo 1. References "],
["demografia.html", "Capítulo 3 Demografía 3.1 Tablas de vida 3.2 Curvas de supervivencia 3.3 Análisis de Curvas de Captura 3.4 Matrices 3.5 Otras fuentes bibliográficas", " Capítulo 3 Demografía En el primer capítulo del material del curso, tratamos algunos modelos de crecimiento, donde factores importantes, como el sexo, la edad y el estado reproductivo de los organismos fueron ignorados. Anteriormente, consideramos a las poblaciones como una masa sin estructura que crece en relación al tiempo, y su propio tamaño. Esto tiene consecuencias importantes a la hora de constrastar las predicciones de los modelos, con datos reales sobre poblaciones. Por ejemplo, en muchas poblaciones aprovechadas, los métodos de captura tienen alta selectividad para ciertas tallas o edades. Por tanto, existe un componente que provoca un efecto asimétrico en la mortalidad de una clase de edad a la siguiente. Utilizar estructuras de edades en los modelos de dinámica de poblaciones, permite predicir algunos efectos de acciones de manejo. Por ejemplo, ¿qué pasa si distribuimos la mortalidad de manera equitativa en todas las clases de edad, o qué pasa si cargamos la mortalidad en cierta clase de edad pero no en las otras? Este tema se refleja en los reglamentos de tallas mínimas para la pesca en Costa Rica, por ejemplo. La estructura por edades, puede entenderse como el aporte de cada clase de edad a la fecundidad, y a la supervivencia de una clase a la siguiente. Por ejemplo, podemos pensar en un modelo sencillo donde tenemos tres estados en una población: neonatos, juveniles y adultos. Los neonatos aportan individuos desde su clase, hacia los juveniles. Los juveniles pueden reproducirse tempranamente, y aportar individuos a los neonatos mediante la reproducción; además, aquellos que sobrevivan pasarán a la calse adulta. Por último, la clase adulta aportará muchos individuos a los neonatos mediante la reproducción, y algunos de ellos sobrevivirán y permanecerán en la misma clase en la siguiente generación (Figura 3.1). Figure 3.1: Ejemplo de las transiciones entre clases de edad En las secciones posteriores, aprenderemos los fundamentos del uso de modelos estructurados por edad, y sus aplicaciones al manejo de recursos naturales. Para ayudar a la comprensión de la teoría, y su aplicación a datos reales, utilizaremos el paquete popbio de . Debemos instalarlo en la computadora, utilizando las siguientes líneas: install.packages(&quot;popbio&quot;) 3.1 Tablas de vida Las tablas de vida resumen un estudio longitudinal, que investiga el destino de los individuos de una cohorte durante su vida (o una muestra de la cohorte). Usualmente, la primer columna de una tabla de vida consiste del número de individuos en una clase de edad. Y las clases de edad, dependen del ciclo de vida de los organismos. Este ordenamiento de los datos permite investigar cuántos individuos sobreviven de una clase de edad a la siguiente. Y apartir de aquí, se construyen otros valores poblacionales importantes. Para construir una tabla de vida, debemos seguir los siguientes pasos: \\(x\\): Definir un intervalo de edad, que sea apropiado para el ciclo de vida de la especie. Puede indicarse únicamente el valor inicial del intervalo en la columna, pero lo ideal es trabajar con el punto medio del intervalo de clase. Por ejemplo, para el intervalo \\([a, b)\\), calculamos el punto medio del intervalo como \\(x = (a+b)/2\\). \\(S_x\\): Indicar el número de supervivientes en esa clase de edad. \\(D_x\\): Anotar el número de muertes en esa clase de edad. Se calcula como \\(D_x = S_x - S_{x+1}\\). \\(l_x\\): Calcular la proporción de sobrevivientes con respecto al número de individuos en la primer clase de edad \\(S_0\\). Para cada fila de la tabla de vida, calcular \\(l_x = S_x/S_0\\). \\(d_x\\): Se calcula como \\(D_x\\), pero la columna con los datos de entrada es \\(l_x\\). Es decir: \\(d_x=l_x-l_{x+1}\\). \\(q_x\\): La tasa de mortalidad, que se calcula como \\(q_x = D_x/S_x\\) ó \\(q_x = d_x/l_x\\). \\(e_x\\): La esperanza de vida promedio. Esta se calcula al sumar todos los sobrevivientes desde la clase de edad \\(x\\) hasta la última, dividido entre el número de supervivientes en la clase \\(x\\). Esta manera de calcular \\(e_x\\) supone que todos los individuos sobreviven desde e inicio de la clase de edad hasta el final y luego mueren. Para corregir restamos a este valor la mitad de la amplitud del intervalo en la clase de edad \\(x\\). Es decir, si la amplitud del intervalo es un año, entonces restamos \\(0.5\\left\\Vert x \\right\\Vert =0.5(1)\\). La fórmula Si tenemos \\(n\\) clases de edad, entonces calculamos \\(e_x = (\\sum_{i=x}^n{S_i})/S_x - 0.5\\left\\Vert x \\right\\Vert\\). Los calculos anteriores son interesantes, pero aún hay datos que se pueden añadir para sacar todo el provecho de las tablas de vida: los datos de reproducción. En el caso de animales, las tablas suelen trabajarse con el número de hembras; además, pueden añadirse datos sobre la descendencia que produce cada hembra (contanto también solo los individuos de este sexo). Por lo tanto, a las columnas anteriores añadimos las siguientes: \\(m_x\\): El número de descendientes hembras por cada hembra de la clase \\(x\\) \\(m_x l_x\\): La producción de nuevas hembras por clase de edad. \\(x\\,m_x l_x\\): paso intermedio para calcular parámetros reproductivos. Y con los resultados de una tabla como esta, podemos calcular parámetros importantes como la tasa de crecimiento neta (\\(R_0\\)), que es la cantidad promedio de descendientes hembras que produce una hembra a lo largo de su vida. También podemos calcular el tiempo medio de generación (\\(T_c\\)), que es tiempo que en promedio dura una hembra en producir una cantidad de descendientes hembra igual a la tasa de crecimiento neta, \\(R_0\\). Estos parámetros los calculamos como: \\[ \\begin{split} R_0 &amp;= \\sum l_x m_x\\\\ T_c &amp;= \\sum x\\, m_x l_x\\\\ \\end{split} \\] El \\(R_0\\) es un reflejo de la tasa de multiplicación (\\(\\lambda\\), ver sección 2.1.1). Es decir, la población crece si \\(R_0 &gt; 1\\), se mantiene estable si \\(R_0 =1\\), y decrece si \\(R_0 &lt; 1\\). También podemos relacionarlo con la tasa intrínseca de crecimiento per cápita \\(\\mathrm{r_m}\\) (ver sección 2.1.2). Para ello usamos la siguiente relación: \\[ \\mathrm{r_m} \\approx \\frac{\\ln(R_0)}{T_c} \\] 3.1.1 Tablas de vida sobre cohortes (tablas horizontales) Este tipo de tablas se construyen al seguir un grupo de organismos de una misma cohorte o generación. Es más utilizado en plantas o animales sésiles; sin embargo, con el financiamiento y el equipo correcto, puede ser utilizado en animales móviles. El paquete popbio de , ofrece varios conjuntos de datos. Uno de ellos sobre una planta llamada Aquilegia. El conjunto de datos contiene información sobre cada planta, y su destino después de muestreos anuales. library(popbio)# cargar paquete data(&quot;aq.trans&quot;)#cargar datos aq.trans -&gt; dat; rm(aq.trans)#crear objeto de trabajo #arreglar niveles del factor dat$status &lt;- factor(dat$stage, levels(factor(dat$stage))[1:4]) attach(dat) head(dat,5)# muestra las primeras 5 filas de datos ## plot year plant stage leaf rose fruits fate rose2 status ## 1 903 1996 1 small 0 0 0 small NA small ## 2 903 1996 2 flower NA NA 1 large NA flower ## 3 903 1996 3 small 0 0 0 large NA small ## 4 903 1996 4 small 1 NA 0 small 0 small ## 5 903 1996 7 small 2 NA 0 large NA small #Construimos una matriz con los datos de sobrevivencia (pop &lt;- table(year,status)) ## status ## year recruit small large flower ## 1996 12 134 17 62 ## 1997 287 75 68 6 ## 1998 186 60 41 80 ## 1999 76 84 57 74 ## 2000 5 58 59 52 ## 2001 5 31 58 8 ## 2002 0 13 16 0 ## 2003 3 6 4 0 #Escogemos una diagonal de la matriz (cohorte) Sx &lt;- numeric(4) for(i in 1:4){ Sx[i] &lt;- pop[(i+2),i] } aqData &lt;- tablaVida(x.sup = 1:4, Sx = Sx) rm(dat, pop, i)# Limpiar un poco Si aplicamos las fórmulas que hemos visto en clase, obtenemos la siguiente tabla de vida: Table 3.1: Tabla de vida para una cohorte de Aquilegia. \\(x\\) \\(S_x\\) \\(D_x\\) \\(l_x\\) \\(d_x\\) \\(q_x\\) \\(e_x\\) 1 186 102 1.000 0.548 0.548 1.312 2 84 25 0.452 0.134 0.298 1.298 3 59 51 0.317 0.274 0.864 0.636 4 8 NA 0.043 NA NA 0.500 3.1.2 Tablas de vida estáticas Para algunos animales grandes y longevos, es impráctico construir tablas de vida horizontales. Así que se toman datos en un momento determinado de tiempo, y la tabla se construye a partir de esta información. Tablas de vida verticales o tiempo-específicas— Estas tablas se construyen cuando se conoce la edad de los organismos. Entonces, se cuentan cuántos individuos hay en cada clase de edad; posteriormente, se cuentan las muertes en cada clase de edad, y se combina la información para construir una tabla de vida. Tablas estacionarias basadas en la edad a la muerte— Estas tablas se construyen con información de cadáveres, o partes de éstos. La edad en los cadáveres debe poder ser establecida claramente para que el método funcione. En Neal (2004), se explica el método con un ejemplo basado en el carnero de Dali Ovis dalli. Donde el investigador recolectó cráneos y determinó la edad de cada uno. Por ejemplo, si recolecto 1000 mandíbulas de algún mamífero, y puedo datar estos huesos, el primer paso es asumir que estos 1000 individuos constituyen la primer clase de edad. Luego, si el número de mandíbulas en la segunda clase de edad \\(S_2\\) es 600, resto el \\(S_x\\) anterior a esta cantidad, y así calculo \\(D_1\\). Es decir, \\(D_1=1000-600\\). Y así sucesivamente. Tablas estacionarias basadas en la estructura de edad de la población— Si la población no cambia en tamaño (la tasa de natalidad iguala la tasa de mortalidad), y si la estructura de edad es un reflejo de la Supervivencia (\\(S_x\\)): podemos asumir que la edad de los individuos puede ser datada de manera precisa, y que hemos obtenido una muestra representativa de la población (Neal 2004). Esto quiere decir, que podemos utilizar la frecuencia en cada clase de edad, y asumir que corresponde a la supervivencia. Y que el cambio de frecuencia de una clase de edad a la siguiente se debe a la mortalidad (\\(D_x\\)). 3.2 Curvas de supervivencia Las tablas de vida pueden mostrar algunos detalles de las estrategias de supervivencia de los organismos. Por ejemplo, ¿tienen cuidado parental, o confían en un gran número de juveniles (o huevos, larvas, semillas) de los cuales un pequeño porcentaje de ellos llegarán a ser adultos? Para ello, podemos utilizar directamente la columna \\(S_x\\) y graficarla contra la columna \\(x\\). Sin embargo, si queremos comparar entre distintas especies, o contra diferentes experimentos o estudios, lo ideal es utilizar una columna normalizada como \\(l_x\\). En algunos casos, para mejorar la visualización de los datos, se multiplica la columna \\(l_x\\) por un factor, generalmente un factor de mil, para mostrar la supervivencia por cada mil individuos. También se puede explorar la mortalidad en cada clase de edad, siguiendo un procedimiento similar; pero, reemplazando \\(l_x\\) por \\(q_x\\). Para ilustrar el procedimiento podemos utilizar los datos del Cuadro 3.1: op &lt;- par() par( mar = c(5, 5, 4, 5) + 0.1) plot(aqData[,1],aqData[,4]*1000, xlab = &quot;Edad&quot;, ylab = &quot;&quot;, axes = FALSE, type = &quot;n&quot;) axis(side = 2, at = c(0,500,1000)) lines(aqData[,1],aqData[,4]*1000, lwd = 2) mtext(side = 2, &quot;Supervivencia x 1000&quot;, line = 3) axis(side = 1, at = 1:4) axis(side = 4, at = c(0,500,1000)) lines(aqData[,1],aqData[,6]*1000, lwd = 2, lty = 2, col = &quot;darkgray&quot;) mtext(side = 4, &quot;Mortalidad x 1000&quot;, line = 3) legend(&quot;topright&quot;, legend = c(&quot;Supervivencia&quot;, &quot;mortalidad&quot;), lty = c(1,2), lwd = c(2,2), col = c(1, &quot;darkgray&quot;)) Figure 3.2: Supervivencia y mortalidad de Aquilegia par(op) rm(aqData) 3.3 Análisis de Curvas de Captura Las curvas de captura fueron desarrolladas para analizar datos en pesquerías. Su objetivo es determinar la tasa de supervivencia, o mortalidad, para una población. Este método asume que todas las clases de edad tienen una misma tasa de supervivencia. Es una herramienta general que puede ser utilizada con tablas de vida estacionarias. En general, el análisis de curvas de captura puede ser utilizado en casos donde se tengan frecuencias de individuos por clase de edad. El análisis de curvas de captura, también puede utilizarse con datos de tallas; siempre y cuando, exista una función que relaciones las tallas con la edad. En este último caso, hay que considerar la incertidumbre que existe al convertir tallas a edades . Figure 3.3: Histograma de tallas de Siphonaria gigas en el RNVS Playa Hermosa-Punta Mala. Datos de 2017-2018. En la mayoría de los casos, tanto con datos de edades como tallas, existirán clases pobremente representadas (Figura 3.3). Esto se debe a que la probabilidad de captura con ese método específico varía en función de la edad o talla. También puede significar que existe una separación espacial en las diferentes edades de la especie; y por tanto, que no fueron representadas en el muestreo. Cuando esto sucede, se utiliza la sección descendente de la curva, y se asume que todas las clases contenidas en esa sección están bien representadas. Una vez que se ha seleccionado el sub-conjunto de datos con el cual se hará la estimación, se pueden utilizar varios métodos para estimar la tasa de supervivencia (o mortalidad). 3.3.1 Método de Chapman y Robson 1960. Estimación de supervivencia usando todas las clases de edad Este método se deriva de asumir que los conteos de individuos supervivientes provienen de una distribución de probabilidad multinomial. En cada una de las clases de edad, la probabilidad de obtener un individuo de edad \\(x\\) tiene una distribución geométrica: \\(f_X(x)=(1-s)s^x\\). Donde \\(s\\) es la probabilidad de sobrevivencia que se desea estimar. El desarrollo del estimador de \\(s\\), se detalla en Skalski, Ryding, and Millspaugh (2005). Y se basa en el concetpo de máxima verosimilitud. Su fórmula es sencilla: \\[ \\hat{s} = \\frac{T}{n+T-1} \\] Donde \\(n\\) es el tamaño de la muestra. \\(T = \\sum_{i=1}^n x_i\\), es decir la suma de las edades de todos los individuos en la muestra. La varianza de \\(\\hat{s}\\), se calcula como: \\[ \\mathrm{Var}(\\hat{s}) = \\hat{s}\\left( \\hat{s} - \\frac{T-1}{n+T - 2} \\right) \\] Suponer que todas las clases de edad mantienen una tasa de supervivencia común es arriesgado. Las suposiciones que se deben cumplir para aplicar este modelo con seguridad son: Existe una estructura de edad estable. La población es estacionaria. Todos los animales tienen una misma probabilidad de selección(captura). La muestra es representativa de la población. El destino de todos los animales es independiente. Todas las edades se estiman sin error. La probabilidad de supervivencia anual es constante a través de todas las clases de edad. 3.3.2 Método de regresión De manera alternativa, se puede utilizar una simple regresión lineal para estimar una tasa de supervivencia común a todas las clases de edad. Para ello, asumimos que el número esperado de individuos contados en una clase de edad \\(x\\) (\\(S_x\\)), es igual un número de reclutas \\(N_0\\), que se mantiene constante a través del tiempo; multiplicado por la probabilidad de que un individuo sea capturado en la muestra \\(p\\); multiplicado por probabilidad de haber sobrevivido hasta la clase \\(x\\) (\\(s^x\\)). Es decir: \\[ E\\left( S_x \\right) = N_0 p s^x \\] Si tomamos logaritmo a ambos lados de la expresión anterior, obtenemos: \\[ \\ln(\\bar{S_x}) = \\ln(N_0 p) + x\\ln(s) \\] Que presenta la forma familiar de una línea recta: \\(y=a+bx\\). Lo importante aquí, es reconocer que \\(s = e^b\\). Así que al estimar los parámetros de la recta, podemos derivar la tasa de supervivencia \\(s\\). Example 3.1 Calcular la tasa de sobrevivencia, usando los datos de Aquilegia (Cuadro 3.1) #Definir los datos para la regresión y &lt;- log(Sx) #Sx, es el conteo de supervivientes de Aquilegia x &lt;- 1:4 # Las clases de edad salida &lt;- glm(formula = y~x, family = gaussian(link = &quot;identity&quot;)) s &lt;- signif( exp(coef(salida)[2]), digits = 3) sLim &lt;- signif( exp(confint(salida)[2,]), digits = 3) ## Waiting for profiling to be done... Con el código de arriba, obtenemos que $s = $ , con un intervalo de confianza al SI{95}{} de . 3.3.3 Ejercicios Exercise 3.1 ¿Cual es el significado ecológico de \\(R_0\\)? Exercise 3.2 Si a usted le piden hacerse cargo de determinar el éxito de un programa de re-introducción, basado en el éxito reproductivo de la especie: Enumere los pasos a seguir para determinar si la especie se reproduce exitósamente, utilizando las herramientas vistas en las tablas de vida? Asuma que ud puede muestrear una cohorte de principio a fin. Exercise 3.3 Calcule si la siguiente población está creciendo, se mantiene estable o está decreciendo: ## x Sx mx ## [1,] 5 20 0.0 ## [2,] 10 45 0.0 ## [3,] 15 10 1.2 ## [4,] 20 5 1.1 Exercise 3.4 En Neal (2004) se presentan los datos sobre el estudio de Ovis dalli. Calcule la tabla de vida: ## x Sx ## [1,] 1 608 ## [2,] 2 487 ## [3,] 3 480 ## [4,] 4 472 ## [5,] 5 465 ## [6,] 6 447 ## [7,] 7 419 ## [8,] 8 390 ## [9,] 9 348 ## [10,] 10 268 ## [11,] 11 154 ## [12,] 12 59 ## [13,] 13 4 ## [14,] 14 2 ## [15,] 15 0 Exercise 3.5 Grafique la curva de supervivencia y mortalidad del ejercicio anterior. 3.4 Matrices ## Warning: package &#39;diagram&#39; was built under R version 3.4.3 ## Loading required package: shape ## Warning: package &#39;shape&#39; was built under R version 3.4.3 Figure 3.4: Un diagrama que representa gráficamente una matriz de transición 3.5 Otras fuentes bibliográficas En Neal (2004) se da una introducción gentil a la demografía, pero los métodos de análisis son limitados a unos pocos; básicamente, se limitan a enseñar las técnicas necesarias para comprender los fundamentos detrás de cada análisis. Por otro lado, Skalski, Ryding, and Millspaugh (2005) describe detalladamente las variantes de cada técnica, con un enfoque práctico; además, presenta discusiones sobre la utilidad de cada método de análisis y sus supuestos. Como nota precautoria, en Skalski, Ryding, and Millspaugh (2005), las convenciones sobre los nombres de las columnas de las tablas de vida difieren a las expuestas en este material. References "],
["soluciones-a-los-ejercicios.html", "Capítulo 4 Soluciones a los ejercicios", " Capítulo 4 Soluciones a los ejercicios Ejercicio 2.1 plot(0,0,xlim = c(0,50), ylim = c(0,100) , type = &#39;n&#39;,xlab = &#39;Tamaño poblacional&#39;, ylab = &quot;Tasa de crecimiento&quot;) val=numeric() for(Rm in c(-1,0,1)){ abline(50,Rm,lty=Rm+2) val=append(val,Rm) } legend(&quot;topleft&quot;,lty= 1:3,legend = paste(&#39;Rm = &#39;,val)) \\(R_m\\) representa la pendiente de la recta. Ejercicio 2.5 En 3 horas existen 12 periodos de 15 minutos (\\(t=12\\)). Entonces aplicamos la ecuación (2.2): \\[ 100\\times 2^{12} = \\num{409600}\\text{ células} \\] Ejercicio 2.6 Obtener \\(r_m = \\ln \\lambda\\); luego multiplicar \\(r_{mes}=r_m \\times 4\\) para obtener la escala a meses. Finalmente, transformar \\(\\lambda_{mes}=e^{r_{mes}}\\). Ejercicio 2.8 Asumimos que \\(r_m\\) es cualquier constante positiva (\\(r_m \\in \\mathbb{R}^+\\)). Entonces \\(-1\\times r_m \\in \\mathbb{R}^-\\). Luego, tomamos el límite: \\[ \\lim_{t \\to \\infty}N_0 e^{-r_m t} \\] Que equivale a: \\[ \\lim_{t \\to \\infty}\\frac{N_0}{e^{r_m t}} \\] Vemos que el denominador de la expresión anterior es un número que crecerá infinitamente. Si reemplazamos \\(e^{r_m t}\\) por \\(x\\), cuando \\(t \\to \\infty \\Rightarrow x \\to \\infty\\). Y quedamos con la expresión: \\[ \\lim_{x \\to \\infty}\\frac{N_0}{x} = 0 \\] Porque cuando \\(x \\to \\infty \\Rightarrow x \\gg N_0\\). Es decir, cuando \\(x\\) se vuelve infinito, es mucho más grande que \\(N_0\\), por tanto, el cociente tiende a cero, cuando \\(x\\) tiende a infinito. Poblacionalmente, esto significa, que si una población mantiene una tasa intrínseca negativa, por un periodo de tiempo suficientemente largo, sufrirá un evento de extinción. Ejercicio 2.11 El tamaño de población que maximiza el crecimiento Reconocemos que la capacidad de carga son \\(K=\\SI{100}{\\kilogram}\\). Por tanto, la cantidad de biomasa que maximiza el crecimiento, según el máximo rendimiento sostenible es \\(K/2=\\SI{50}{\\kilogram}\\). ¿Cuánta biomasa se debe extraer en un día para mantener la tasa de crecimiento al máximo? Debemos utilizar unidades congruentes durante los cálculos. Así que el primer paso convertir \\(r_m\\) de a . \\[ \\frac{\\num{5e-6} } {\\cancel{ \\si{\\second} } } \\frac{\\num{86400}\\cancel{\\si{\\second}} }{\\si{\\day}}= \\frac{\\num{0.432}} {\\si{\\day}} \\] Ahora podemos calcular el Máximo Rendimiento Sostenible, reemplazando los valores apropiados en: \\[ MRS=\\frac{r_m K}{4} = \\SI{10.8}{\\kilogram} \\] ¿A qué biomasa total se debe cosechar el tanque? Esta es la suma del tamaño de población al máximo rendimiento sostenible, más el máximo rendimiento sostenible: \\[ \\frac{K}{2} + \\frac{r_m K}{4} = \\SI{60.8}{\\kilogram} \\] Ejercicio 3.3 M &lt;- matrix(c( 5,10,15,20, 20,45,10,5, 0,0,1.2, 1.1 ), ncol = 3, byrow = FALSE) colnames(M) &lt;- c(&quot;x&quot;,&quot;Sx&quot;,&quot;mx&quot;) lf &lt;- tablaVida(x.sup=M[,&quot;x&quot;],Sx=M[,&quot;Sx&quot;], mx=M[,&quot;mx&quot;]) re &lt;- log(lf$R0)/lf$Tc if (re &gt; 1){ print(&quot;Está creciendo&quot;) } else if (re == 1 ){ print(&quot;Se mantiene constante&quot;) } else if ( re &lt; 0 ){ print(&quot;Está decreciendo&quot;) } ## [1] &quot;Está decreciendo&quot; rm(M) Ejercicio 3.4 Table 4.1: Tabla de vida para Ovis dalli. \\(x\\) \\(S_x\\) \\(D_x\\) \\(l_x\\) \\(d_x\\) \\(q_x\\) \\(e_x\\) 1 608 121 1.000 0.199 0.199 7.071 2 487 7 0.801 0.012 0.014 7.703 3 480 8 0.789 0.013 0.017 6.808 4 472 7 0.776 0.012 0.015 5.915 5 465 18 0.765 0.030 0.039 4.997 6 447 28 0.735 0.046 0.063 4.178 7 419 29 0.689 0.048 0.069 3.424 8 390 42 0.641 0.069 0.108 2.641 9 348 80 0.572 0.132 0.230 1.899 10 268 114 0.441 0.188 0.425 1.317 11 154 95 0.253 0.156 0.617 0.922 12 59 55 0.097 0.090 0.932 0.602 13 4 2 0.007 0.003 0.500 1.000 14 2 2 0.003 0.003 1.000 0.500 15 0 NA 0.000 NA NA NaN Ejercicio 3.5 op &lt;- par() par( mar = c(5, 5, 4, 5) + 0.1) plot(lf[,1],lf[,4]*1000, xlab = &quot;Edad&quot;, ylab = &quot;&quot;, axes = FALSE, type = &quot;n&quot;) axis(side = 1, at = lf[,1]) axis(side = 2, at = c(0,500,1000)) lines(lf[,1],lf[,4]*1000, lwd = 2) mtext(side = 2, &quot;Supervivencia x 1000&quot;, line = 3) axis(side = 4, at = c(0,500,1000)) lines(lf[,1],lf[,6]*1000, lwd = 2, lty = 2, col = &quot;darkgray&quot;) mtext(side = 4, &quot;Mortalidad x 1000&quot;, line = 3) legend(&quot;top&quot;, legend = c(&quot;Supervivencia&quot;, &quot;mortalidad&quot;), lty = c(1,2), lwd = c(2,2), col = c(1, &quot;darkgray&quot;)) par(op)# restaurar valores por defecto para plot rm(lf)#limpiar un poco Según el gráfico anterior, existe un primer pico de mortalidad en las crías de un año o menos. Posteriormente la mortalidad es muy baja hasta los ocho años, cuando empieza a incrementar. Probablemente, a partir de los ocho años, las cabras de monte empiezan a envejecer y a perder sus cualidades para sobrevivir. "],
["metodos-numericos-para-ecologia-de-poblaciones.html", "A Métodos numéricos para ecología de poblaciones A.1 Simulación de ecuaciones diferenciales A.2 Error en las simulaciones", " A Métodos numéricos para ecología de poblaciones A.1 Simulación de ecuaciones diferenciales Tomaremos el ejemplo de la ecuación (2.3), para mostrar un método para encontrar el tamaño de población, sin tener que utilizar cálculo (Barrantes Campos 2015). Este es el método de Euler, que se explicará mediante un ejemplo. Una derivada implica un cambio infinitesimal de una variable en relación a otra. Por ejemplo, el cambio en el número de individuos de una población en un momento pequeñísimo de tiempo, puede representarse como la diferencia de la población, entre la duración de ese pequeño intervalo de tiempo: \\[ \\frac{dN}{dt} \\approx \\frac{\\Delta N}{\\Delta t} = \\frac{N_t - N_{t-\\Delta t}}{\\Delta t} \\] Si sustituimos en la ecuación (2.4), tenemos: \\[ \\frac{N_t - N_{t-\\Delta t}}{\\Delta t} = r_m N \\] Arreglando la expresión anterior, podemos despejar en terminos de \\(N_t\\): \\[ N_t= N_{t-\\Delta t} + r_m N_{t-\\Delta t} \\Delta t \\] Hay que resaltar que esta no es una solución exacta; sino, una aproximación. Entre más pequeño se haga \\(\\Delta t\\), más se aproximará el resultado, al valor exacto dado por (2.4). En casos donde no existe una solución analítica, o simplemente, no es sencillo resolver la ecuación, siempre se puede recurrir a los métodos numéricos, para tener una idea de la solución real. Para programar este sencillo ejemplo, necesitamos varios pasos: Definir un valor inicial de la población, y el valor de \\(t\\) en el cuál queremos conocer el tamaño de población. Definir el Valor de \\(r_m\\). Establecer un criterio para guardar el valor de \\(N_t\\), cada cierto lapso de tiempo. (Para no crear un objeto virtual innecesariamente grande) Crear un objeto para guardar el tamaño de la población, y los puntos de tiempo a los que está asociada. Definir el tamaño de \\(\\Delta t\\), y calcular el número de iteraciones necesarias hasta llegar al final del periodo de tiempo de interés. Crear un bucle, y ejecutar iteractivamente la integración de Euler. Definir un criterio para detener el algoritmo. El siguiente algoritmo generaliza todas las funciones dependientes de \\(N_{t-\\Delta t}\\). \\[ N_t= N_{t-\\Delta t} + f \\left( N_{t-\\Delta t},\\mathbf{c} \\right) \\Delta t \\] Donde \\(\\mathbf{c}\\) son constantes. euler &lt;- function( fooName, valInic, tiempoParar, NoIter, guardarCada, ...) { arg &lt;- list(...) fn &lt;- get(fooName) #Encuentra los argumentos provistos argName &lt;- match.arg(names(arg), #arg provistos formalArgs(fn), #arg existentes several.ok = TRUE) #Nombra la lista con los nombres de los argumentos provistos names(arg) &lt;- argName deltaT &lt;- tiempoParar/NoIter val &lt;- numeric() val[1] &lt;- valInic valTmp &lt;- numeric() valTmp &lt;- val[1] #Completa la lista de argumentos con N[t-1] arg[[(length(arg) + 1)]] &lt;- valInic totalArg &lt;- length(arg) #Escribe todos los nomres de los argumentos, para do.call names(arg) &lt;- formalArgs(fn)#Encuetra los nombres de los argumentos tiempo &lt;- numeric() counter &lt;- 0 tNow &lt;- 0 tiempo[1] &lt;- 0 while (tNow &lt; tiempoParar) { valTmp &lt;- valTmp + do.call(fn, args = arg) * deltaT tNow &lt;- tNow + deltaT arg[[totalArg]] &lt;- valTmp counter &lt;- counter + 1 if (counter == guardarCada) { val &lt;- append(x = val, values = valTmp) tiempo &lt;- append(x = tiempo, values = tNow) counter &lt;- 0 } } return(list( poblacion = val, tiempo = tiempo, tNow = tNow, arg = arg, Dt = deltaT )) } Por ejemplo: diffG1 &lt;- function(rm, N) N * rm N0 &lt;- 10 Resultados1 &lt;- euler(fooName = &quot;diffG1&quot;, valInic = N0, tiempoParar = 10, NoIter = 100, guardarCada = 10, rm = 0.22) diffG2 &lt;- function(rm, Kmax, N) rm * (1 - N/Kmax) N0 &lt;- 10 Resultados2 &lt;- euler(fooName = &quot;diffG2&quot;, valInic = N0, tiempoParar = 50, NoIter = 500, guardarCada = 50, rm = 1.92, Kmax = 60) plot(Resultados1$tiempo, Resultados1$poblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(Resultados1$tiempo, Resultados1$poblacion) plot(Resultados2$tiempo, Resultados2$poblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(Resultados2$tiempo, Resultados2$poblacion) A.2 Error en las simulaciones Hemos mencionado que la integración de Euler es una aproximación a la función verdader. Que tan bien o mal sea esta aproximación depende de la elección de \\(\\Delta t\\). Figure A.1: Comparación del efecto del tamaño del \\(\\Delta t\\) Por ejemplo en la figura A.1 la línea negra representa la ecuación verdadera, la línea gris contínua representa una aproximación con \\(\\Delta t = 1/2\\), y la línea gris discontinua representa una aproximación con \\(\\Delta t = 1/100\\). Observamos que la distancia de la línea con \\(\\Delta t = 1/100\\) con la curva real es menor que la distancia de la línea con \\(\\Delta t = 1/2\\) a la curva real. Es decir, si disminuimos el valor de \\(\\Delta t\\) disminuye el error de la aproximación A.2. Figure A.2: Porcentaje de error para \\(N\\) en \\(t=5\\) según el \\(\\Delta t\\) En este caso, solo se calculó el error para el valor de \\(N_{t=5}\\). References "],
["tutorial-de-r-con-rstudio.html", "B Tutorial de R con RStudio B.1 Crear un proyecto en RStudio B.2 Funciones básicas en R B.3 Estructuras de datos B.4 Funciones", " B Tutorial de R con RStudio B.1 Crear un proyecto en RStudio Crear un proyecto en RStudio para cualquier proyecto con R, es importante. Los proyectos organizan los documentos en una sola carpeta, y son fundamentales para el control de versión con un software como Git. Abrimos RStudio, y ubicamos la barra de herramientas en la parte superior. El primer paso es ir a file --&gt; New Project. Creamos una carpeta en una ubicación que nos permita tener derechos de administrador, e idealmente, fuera de cualquier carpeta de sincronización en línea. RStudio nos guiará por los siguientes pasos: Crear un Proyecto: Escogemos que sea un nuevo directorio. Tipo de Proyecto: Escogemos nuevo proyecto. Crear: Escogemos la carpeta, y el nombre del proyecto. NO marcamos crear repositorio con Git. Figure B.1: Cómo hacer un nuevo proyecto, en . Volvemos a la barra de herramientas, en RStudio, y vamos a File --&gt; New file --&gt; R script. Este archivo solo soporta código en R, con la gran ventaja de que colorea las funciones, variables y estructuras más comunes; lo cual, hace que el código sea más legible. IMPORTANTE: En el siguiente tutorial, el código en R se encuentra dentro de ambientes especiales, rodeados por una caja gris. Escribe las líneas que se muestran en esa caja, y para ver el resultado en la consola de R, apreta Ctrl + ENTER. B.2 Funciones básicas en R Ahora que hemos creado un proyecto, y tenemos un lienzo en blanco, empezamos por ver las funciones más elementales. R contiene todas las operaciones básicas como: adición, substracción, multipliación, división, potencias, y logaritmos. # Tras cada línea presiona Ctrl + ENTER 1 + 1 # adición 1-1 # substracción 1*2 # multiplicación 1/2 # división 2^(8) #potencia log(2) # logaritmo natural log10(2) #logaritmo base 10 log(x = 2, base = &lt;n&gt;) #logaritmo base &lt;n&gt;, donde &lt;n&gt; se # reemplaza por cualquier número. Notar que en el código, cualquier línea de texto precedida de # es un comentario, que no será evaluado por el computador. Agregar comentarios es muy útil, si uno va a re-utilizar parte del código en otro momento. Ayuda a mantener la claridad en lo que se está haciendo. Continuando con las operaciones básicas, también podemos mezclar operaciones de la forma que convenga. Siempre considerando las reglas de prioridad por paréntesis. Por ejemplo, si queremos calcular el logaritmo del resultado de una función, para una base 16. log( x= 1 / (1 + (5/2) ) , base = 16 ) Luego, como la mayoría de lenguajes de programación, podemos asignar valores a un objeto y utilizarlo después en otra operación: a &lt;- log10(4/3) # &#39;a&#39; tiene el valor de la operación b &lt;- a^2 # Equivale a log10(4/3)^2 c &lt;- b^2 - a c Esto quiere decir que podemos crear un objeto con el operador &lt;-, que pueden ser datos, o resultados de otras operaciones, para incluirlo en una nueva función. Por lo que la salida de una función puede ser la entrada de la próxima. Figure B.2: Flujo de entradas y salidas en una función de B.3 Estructuras de datos R puede manejar objetos muy complejos; sin embargo, estos objetos generalmente se componen de partes muy sencillas. Revisaremos éstas partes sencillas, y luego crearemos un objeto más complejo. Vectores Un vector en programación, es una colección de uno o más valores. Podemos pensar que un vector en R equivale a una matriz de \\(n\\) filas, y solo una columna. vect1 &lt;- c(1,2,3,4,5,6,7,8,9,0) #es una concatenación de # números, que se crea con la función &#39;c(...)&#39; vect2 &lt;- rnorm(10) # son diez números al azar obtenidas # de una distribución normal estándar Los elementos de un vector pueden ser llamados utilizando un sub-índice. Éste inicia en 1, hasta \\(n\\). Donde \\(n\\) es la cantidad de elementos en un vector. vect1[3] También es posible llamar varios elementos a la vez, si el subíndice del vector es otro vector. vect1[c(3,4,5)] vect1[3:5] # 3:5 crea una secuencia de enteros, que incrementa en 1 a la vez. vect1[rep(5,times=10)] # rep, es una función que repite un #número un determinado número de veces. Los vectores pueden ser datos en un archivo externo, o resultado de funciones u operaciones. A diferencia de otros lenguajes R, maneja vectores de una forma más intuitiva. vec3 &lt;- vec1 + vec2 # es un nuevo vector basado en la adición de los dos primeros. Matrices Las matrices son un arreglo de datos en dos dimensiones, es decir, filas y columnas. Por covención, cuando decimos que una matriz es de tamaño \\(f\\times c\\), nos referimos a que tiene \\(f\\) filas, y \\(c\\) columnas. Las filas siempre se nombran primero que las columnas. (m1 &lt;- matrix(1:9, ncol=3, byrow = T) ) (m2 &lt;- matrix(1:9, ncol=3, byrow = F) ) Los elementos de una matriz se llaman por la combinación de filas y columnas a la que corresponde. Del ejemplo anterior, si quisiéramos obtener el elemento central de la matriz m1, lo llamamos así m1[2,2]. Si quisiéramos llamar toda la primer columna, entonces escribimos m1[,1]. O la primer y tercer fila m1[c(1,3),]. Las operaciones con matrices suelen ser más delicadas y existen operadores específicos para ellas. Marco de datos o Data frames Esta estructura es similar a una matriz, con la diferencia, que algunas de sus columnas pueden contener factores, y no solo valores numéricos. Estas son las estructuras con las que representamos un diseño experimental, por ejemplo: ## Var1 Var2 z ## 1 T1 a -0.998 ## 2 T2 a 0.337 ## 3 T1 b -0.120 ## 4 T2 b -1.055 ## 5 T1 c 0.654 ## 6 T2 c 1.371 Arreglos o arrays Estos son matrices de 3 o más dimensiones. Por ejemplo, si tenemos una serie de fotografías con la misma resolución, en el mismo lugar, podemos representar los pixeles como una matriz \\(f\\times c\\), y el tiempo como una dimensión adicional. Si ponemos en rápida sucesión las matrices, tendremos un video o película. array(1:(6*2),dim=(c(2,3,2))) Listas Las listas son colecciones de cualquiera de los objetos anteriores (y otros que no hemos visto). l1 &lt;- list( vector = vect1, matriz = m1 ) Podemos llamar a los elementos de una lista, de dos formas: si conocemos el orden de los elementos de la lista, entonces, escribimos el índice dentro de dos pares de corchetes rectos: l1[[1]], para llamar el vector y l1[[2]], para llamar la matriz. Si conocemos los nombres de los elementos de la lista, usamos la siguiente forma: l1$vector, para el vector; y l1$matriz, para la matriz. Una vez dentro del objeto de la lista, podemos llamar sus elementos de manera tradicional. Por ejemplo, l1$matriz[2,2], para llamar el elemento central de la matriz dentro de la lista. B.4 Funciones Las funciones se representan por un nombre, seguido de un paréntesis redondo. Todo lo que esté dentro de ese paréntesis son sus argumentos. Para finalizar la función, cerramos con un paréntesis redondo derecho: funcion(argumento1 = valor1, argumento2 = valor 2) Nosotros podemos crear nuestras propias funciones en R. El procedimiento es sencillo: Llamamos a la función con un nombre, y declaramos que se trata de una función Nombramos los argumentos de la función. Podemos asignar valores por defecto. Los argumentos deben ir entre paréntesis redondos. Escribimos el cuerpo de la función entre paréntesis tipo llave {}. El cuerpo de la función debe terminar con un solo objeto que será retornado como salida del proceso. Por ejemplo, si queremos hacer nuestra propia función para calcular un promedio. Primero debemos entender la fórmula subyacente: \\[ \\bar{x}= \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Es decir, sumamos todos los elementos de un vector de valores, y lo dividimos por el tamaño del vector. Entonces, nuestro argumento será un vector, y nuestra salida, un valor único con el promedio. promedio &lt;- function(vectorX){ sumaX &lt;- sum(vectorX) n &lt;- length(vectorX) #length(), es una función que calcula # el tamaño del vector. valor &lt;- sumaX / n return(valor) } # Ahora probamos la función, tomando el promedio de un # vector de números normales con media igual a cero # Esperamos, que nuestro promedio sea un valor cercano # a cero. valores &lt;- rnorm(100) (promedio(valores)) ## [1] 0.128 "],
["asignaciones.html", "C Asignaciones C.1 Tarea 01: ¡Hola mundo con Rmarkdown! C.2 Tarea 02: Ejercicios de crecimiento C.3 Tarea 03 C.4 Tarea 04: Ejercicios con tablas de vida C.5 Tarea 05 C.6 Tarea 06 C.7 Trabajo grupal", " C Asignaciones C.1 Tarea 01: ¡Hola mundo con Rmarkdown! Objetivo: Verificar que el estudiante ha instalado, y maneja el ambiente de trabajo que se utilizará durante el curso. Primero revisa los enlaces provistos en el wiki. Actividades Haz un nuevo proyecto en RStudio, que se llame Tarea01. Ver pasos en sección B.1. En la consola de R, escribe install.packages(rmarkdown), con todas las dependencias. O instala el paquete desde RStudio como se mostró en el wiki. En RStudio File--&gt; New File --&gt; R Markdown. Crea una sección principal que se llame Información profesional. Luego, crea una sección secundaria que se llame Intereses. Usa bullets para nombrar algunos intereses profesionales. Luego, crea una sección secundaria llamada Experiencia Laboral, si aplica. Nombra algunos trabajos relacionados con el curso de Ecología de Poblaciones. Crea una sección principal que se llame Integración con R Consigue algunos datos interesantes en Internet. Deben ser datos para graficar, por tanto deben tener dos columnas, y varias filas. Puedes ir a Wolfram Alpha. Guarda los datos como un texto delimitado por comas (.csv). En R o RStudio corre el comando ?read.table. Para correr un comando en RStudio presiona Cntrl + R. Crea un “chunk” de código. Esto se hace en RStudio, busca un botón en la barra especial de rmarkdown que diga insert, luego escoge R. Lee la tabla y asígnala a un objeto: datos &lt;- read.table(&lt;ruta_de_archivo_en_comillas&gt;, header = TRUE, sep = &quot;,&quot;) Grafica los datos en un nuevo “chunk”. Usa el método que prefieras. Hay mucho material de cómo hacer gráficos en R. Por ahora, un gráfico básico es suficiente. Ahora, haz otra sección llamada Bibliografía. En un párrafo escribe una mini-revisión de algún tema que domines y del que dispongas referencias bibliográficas. Usa los mecanismos de citas de rmarkdown Cita en texto con @citationKey Cita en paréntesis con [@citationKey] Importante: Para que las citas funcionen, debes agregar unas opciones en la cabecera del documento (YAML header): bibliography: &lt;tu_archivo_bib&gt;.bib csl: apa.csl El archivo apa.csl se puede encontrar en google. Es un archivo de estilo APA, para dar formato a la bibliografía. Revisa el repositorio de CSL de Zotero, en busca de las revistas disponibles. Por último, corre el documento con el botón knit. Envía el documento .Rmd y el .pdf al profesor (dawidh15@gmail.com). C.2 Tarea 02: Ejercicios de crecimiento Se recomienda hacer primero todo en papel, y luego pasarlo en limpio usando Rmarkdown. Uno de los aspectos más sobresalientes de LaTeX es el aspecto de las ecuaciones. Los cálculos realizados en este ejercicio son una buena excusa para investigar un poco sobre el tema. Se recomienda este link C.2.1 Instrucciones Resuelva el siguiente ejercicio de crecimiento exponencial En un laboratorio se cultiva una especie presa para un programa de re-introducción de una especie de pez. En el laboratorio, se inició un proyecto de mejora en la producción de la presa, y se ha diseñado un experimento para aumentar el valor nutricional de las presas. Se cuenta con un presupuesto de para la producción de animales presa en el proyecto. Además, el diseño experimental requiere de 40 recipientes acondicionados con diferentes tratamientos. Las presas crecen con una tasa de crecimiento intrínseco de \\(r_m = \\SI{0.098}{\\per\\day}\\). Además, el inóculo inicial es de individuos por recipiente. Si se sabe que el costo de mantenimiento por organismo-día es de : ¿Cuántos organismos por recipiente se pueden cultivar sin sobrepasar el dinero disponible? ¿Cuánto tiempo, en días, se necesitan para alcanzar esa cantidad? Tips: Este es un problema de mínimos. Primero hay que buscar la función a minimizar. Luego, uno encuentra el valor apropiado del parámetro de interés cuando la función se minimiza. Para minimizar una diferencia, use el valor absoluto de la diferencia: \\(\\left| x - y\\right|\\). Use la función optim o optimize. Una vez que tenga la función que desea minimizar escrita en R use este código: out &lt;- optim(par = 0,fn = &lt;nombre_de_funcion_para_minimizar&gt;, control = list(reltol=0.01), method = &quot;Brent&quot;, lower = &lt;numero&gt;, upper = &lt;numero&gt;) Antes se recomienda buscar la ayuda de la función en la consola de R, al escribir ?optim. Revise los ejemplos, y lea detalladamente la ayuda. C.3 Tarea 03 C.4 Tarea 04: Ejercicios con tablas de vida C.4.1 Objetivo general Valorar la importancia de las tablas de vida, para el manejo de recursos naturales. C.4.2 Instrucciones Lea el problema y aplique las tablas de vida para resolver la pregunta Asuma que usted es parte de un grupo consultor que ha desarrollado un plan de manejo para un área que protege el ciclo reproductivo de una población de cabra de monte, como base alimenticia de grandes depredadores. Después de un muestreo intensivo, se obtiene una distribución de frecuencias por edad para las hembras. Tras corregir las frecuencias en cada talla, se utiliza el método de tablas estacionarias basadas en la estructura de edad de la población, para construir las clases de edad y supervivientes. También se obtuvo un promedio de las crías hembra sobrevivientes en cada clase de edad por hembra. Los datos obtenidos son los siguientes: ## x Sx mx ## [1,] 1 205 0.00 ## [2,] 2 96 0.00 ## [3,] 3 94 1.01 ## [4,] 4 89 1.01 ## [5,] 5 79 1.01 ## [6,] 6 68 1.01 ## [7,] 7 55 1.01 ## [8,] 8 43 1.01 ## [9,] 9 32 1.01 ## [10,] 10 22 1.01 ## [11,] 11 15 1.01 ## [12,] 12 10 1.01 ## [13,] 13 6 0.00 Los administradores del área protegida están de acuerdo, en que se considera que el plan de manejo es efectivo, si la población de cabras aumenta o se mantiene constante. Ellos le han solicitado que usted haga esta evaluación, y les brinde los resultados. ¿Es el plan de manejo efectivo? C.4.3 Presentación Presente la tarea en un archivo R Markdown, usando la plantilla de abajo. Complete las secciones del código que se solicitan. Corra el código y verifique que funcione, y que los resultados tienen sentido. De su respuesta a los administradores del área protegida. Envíe solo el archivo .Rmd al profesor. Descargue la plantilla para la tarea aquí C.5 Tarea 05 C.6 Tarea 06 C.7 Trabajo grupal C.7.1 Objetivo general Aplicar los conocimientos del curso en una simulación de un proyecto colaborativo, utilizando las herramientas de trabajo vistas en el curso (, R Markdown, Git y GitHub), para que el estudiante se familiarice con las nuevas tendencias de Open Science. C.7.2 Objetivos específicos Sintetizar el aprendizaje en un informe científico de la investigación, usando las herramientas de trabajo vistas en clase. Valorar la importancia la justificación del procedimiento de análisis para escoger el método de toma de datos. Aplicar los conocimientos teóricos del curso mediante una proyección sobre la probabilidad de extinción local de las poblaciones que vamos a muestrear. Entender la importancia de verificar si nuestros resultados cumplen las suposiciones de nuestro procedimiento de análisis en la discusión del informe. C.7.3 Justificación La ciencia tiene principios fundamentales muy estrictos. Uno de ellos es la repetibilidad y/o reproducibilidad de los hechos con los cuales se fundamentan las hipótesis o las teorías. Los trabajos en ecología presentan problemas de repetibilidad y reproducibilidad en el campo, pero de hecho, sí podemos corroborar los resultados y el cumplimiento de supuestos de los análisis de otras personas. Incluso, podemos mejorar el trabajo de otros en colaboración, siempre y cuando, tengamos acceso a cierta información de estos estudios. Muchos investigadores e instituciones, como editoriales científicas, entienden que para la ciencia es necesario un mejor flujo de información (British Ecological Society 2014; Croucher et al. 2017). El éxito de algunas iniciativas de colaboración y Open Science, radica en este principio. Por ejemplo, los investigadores que desarrollan análisis bioestadísticos se han beneficiado de divulgar sus procedimientos al público; ya que, investigadores similares colaboran con ellos y constantemente mejoran los análisis, corrigen errores, o sugieren nuevas alternativas o métodos. Y esto solo ha ocasionado el beneficio de los numerosos usuarios de sus paquetes, y de la calidad de los análisis y por ende, las decisiones basadas en resultados. Es importante que los estudiantes de esta licenciatura conozcan estas nuevas tendencias, y las herramientas que las han hecho posibles. Por ello, montaremos una simulación de un trabajo colaborativo en el campo de la Ecología de Poblaciones Silvestres. C.7.4 Definiciones mortalidad: Se refiere a la cantidad de individuos que mueren de una clase de edad o talla a la siguiente. supervivencia: Es lo opuesto a la mortalidad. Es la cantidad de individuos que sobrevive de una talla a la siguiente. fecundidad: La cantidad de huevos que produce cada individuo de Siphonaria spp. o de Strombus spp. Matrices de transición: Es una matriz que contiene elementos de mortalidad o supervivencia y fecundidad, Se utiliza para hacer proyecciones del tamaño de una población. fecha de cumplimiento: Es la fecha en la que una meta ya debe haberse concretado. HEAD. Es un término de Git que se refiere a la versión más reciente de un documento que usa control de versión. C.7.5 Metas Meta 1, (7%). Fecha de cumplimiento 19 de abril: Generar una revisión bibliográfica sobre temas relacionados con la ecología poblacional de Siphonaria gigas (o similares), y de Strombus galeatus (o S. gigas). Los estudios incluidos deben contener información sobre: Crecimiento: talla de los animales en relación al tiempo. Mortalidad: estimaciones numéricas o datos de mortalidad Supervivencia: estimaciones numéricas o datos de supervivencia Matrices de transición: todo lo relacionado con este tema. Análisis de viabilidad de poblaciones: todo lo relacionado con este tema. Durante la revisión bibliográfica es importante utilizar estos puntos como criterios de aceptación para un artículo. Si no contiene información sobre estos criterios, entonces no vale la pena incluirlo en la revisión. Si el estudiante no está familiarizado con las herramientas de búsqueda bibliográfica y bases de datos suscritas por la Universidad Nacional, es su responsabilidad informarse con la bibliotecaria de la Unidad Académica. Meta 2, (7%). Fecha de cumplimiento 3 de mayo: Definir el procedimiento de análisis. Se basarán en la teoría, en las investigaciones individuales, y en una búsqueda general en línea, para escoger un procedimiento de análisis que permita calcular la probabilidad de extinción de las poblaciones de interés a cinco años. Meta 3, (5%). Fecha de cumplimiento 10 de mayo: Diseño de muestreo. Solo hay tiempo para un sitio por población. Por tanto, el diseño de muestreo se refiere al establecimiento de las variables que se deben medir en el campo, a los formularios de campo, al procedimiento para tomar los datos y al diseño de la base de datos (se recomienda una base de LibreOffice Base). Meta 4, (3%). Fecha de cumplimiento 24 de mayo: Almacenamiento y control de calidad de datos. Esto se hará durante la gira, y la semana que sigue. Se debe comparar los formularios con los datos digitales en búsqueda de errores. Meta 5, (3%). Fecha de cumplimiento 31 de mayo: Análisis de datos. Utilizar el procedimiento de análisis y aplicarlo a los datos de campo. Idealmente, el análisis ya debería estar montado y probado en el documento principal. Por tanto, solo habría que reemplazar los datos de prueba con los reales. Meta 6. Fecha de cumplimiento 14 de junio: Entrega del informe final. La discusión implica comparar los datos de entrada con los requisitos y supuestos del modelo, para analizar si la salida del procedimiento de análisis es válida o no. Esa fecha el informe debe ser entregado, para que el profesor lo revise. No se aceptan prórrogas. El informe debe ser entregado, para hacer efectivo el porcentaje obtenido en cada una de las metas anteriores en la nota final. Es decir, si el informe final no se entrega en esa fecha, se pierde todo el 25% del valor. C.7.6 Flujo semanal de trabajo Para mantener el orden en el progreso del trabajo, se sugiere la siguiente metodología: Primero, cada estudiante debe empezar por recopilar información sobre los géneros y especies mencionadas. Deben aplicar la lista de criterios para ver si la información es útil o no. El estudiante debería crear un archivo R Markdown con anotaciones sobre la información relevante del documento, e incorporar la información bibliográfica de cada documento revisado a un archivo .bib. Luego, para iniciar la elaboración del informe grupal, el profesor debe haberles enseñado el uso de Git, y GitHub. En clase se explicará como crear y sincronizar una carpeta de trabajo en colaboración. El profesor será el “editor” del trabajo, es decir, él manejará la carpeta maestra, y cada estudiante es un colaborador. Cada semana, los estudiantes asignarán a una persona encargada de manejar el HEAD (es decir, la versión más reciente del documento). Después de la sesión teórica, se discutirán las incorporaciones y cambios del HEAD con respecto a la versión del editor. Si se aprueban los cambios en esa sesión, el estudiante enviará una propuesta de cambios al editor ( en lenguaje de Git, esta propuesta se conoce como un Pull Request). El editor acepta la propuesta, y la sube al documento maestro. Posteriormente, todos los estudiantes se sincronizan con el documento maestro. Si el editor no acepta los cambios, siempre aceptará el HEAD en el documento maestro, pero añadirá una serie de tareas y correcciones que los estudiantes deberán incorporar durante la semana. Estos pasos se repiten semanalmente, hasta finalizar el documento. "]
]
