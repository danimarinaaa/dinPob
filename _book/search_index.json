[
["index.html", "Ecología de poblaciones silvestres Capítulo 1 Introducción", " Ecología de poblaciones silvestres David Martínez Cascante 2018-03-07 Capítulo 1 Introducción La ecología de poblaciones se centra en el estudio de la dinámica de las poblaciones (su crecimiento e interacción con otras poblaciones), y en las interacciones de éstas con el ambiente. La ecología de poblaciones (también llamada dinámica de poblaciones) es un campo con un componente matemático y estadístico fuerte, y de gran importancia para la gestión de vida silvestre. Algunas de las aplicaciones más importantes de esta disciplina, están relacionadas al cálculo de la viabilidad de poblaciones, al cálculo de tasas de extracción, e incluso a la creación de áreas protegidas dedicadas a proteger el ciclo de vida, o parte de éste, en determinadas especies. El Análisis de Viabilidad de Poblaciones, es un ejemplo de una de las aplicaciones de la ecología de poblaciones para la gestión de vida silvestre. Este modelo predice el riesgo de que una población se extinga en una determinada cantidad de años. De esta manera, los gestores pueden modelar diferentes escenarios, cada cual con un conjunto específico de acciones de manejo, y decidir cuál de éstos es más efectivo en la conservación o manejo de la especie. La creación de santuarios de pesca, por ejemplo, se fundamenta en el concepto de Biogeografía de Islas (REF) que también es parte de la ecología de poblaciones. Los santuarios de pesca funcionan como fuentes, es decir, zonas donde el crecimiento poblacional es positivo y existe migración de individuos. Éstos individuos, que se producen en exceso, migrarán hacia zonas de pesca, o extracción, para sostener actividades económicas. De esta manera, se garantiza la extracción sostenible en las zonas aledañas. Algunos modelos importantes, como el modelo bioeconómico, que buscan la mayor rentabilidad económica por la extracción de una especie (Grafton et al. 2006), están basados en modelos de crecimiento derivados de la dinámica de poblaciones. Este modelo estima la cantidad de esfuerzo extractivo que debe aplicarse a una especie, para mantener una rentabilidad positiva, y mantener un tamaño poblacional que garantice la continuidad de las poblaciones aprovechadas. La dinámica de poblaciones es una de las ramas de la biología con un componente matemático y estadístico más fuertes. El desarrollo teórico de los modelos implica conocimiento de planteamiento y resolución de ecuaciones diferenciales. En la práctica, muchos problemas se plantean como ecuaciones diferenciales, pero no tienen solución analítica, por lo cual se requiere de conocimiento sobre métodos numéricos, programación o uso de lenguajes de programación. La mayoría de profesionales, no son desarrolladores teóricos, pero deben saber, al menos, sobre el uso de herramientas de análisis para esta disciplina. Si el investigador conoce las herramientas de análisis, y quiere ponerlas en práctica, entonces requiere de conocimientos en diseño experimental y muestreal; así como, técnicas de muestreo para conseguir los datos. Pero la limitación más fuerte, es el financiamiento requerido; ya que, la mayoría de los análisis tienen fuertes requerimientos de datos, y series de tiempo bastante amplias. References "],
["modelos-de-crecimiento.html", "Capítulo 2 Modelos de crecimiento 2.1 Crecimiento denso-independiente 2.2 Crecimiento denso-dependiente 2.3 Otras fuentes bibliográficas", " Capítulo 2 Modelos de crecimiento HACER: conceptos de producción en exceso, de Darwin, y lucha por la existencia. La evolución por selección natural implica que en una población que enfrente presiones para subsistir, existirán individuos mejor adaptados que otros. Algunos vivirán lo suficiente para reproducirse y otros no; además, dentro de aquellos que se reproduzcan, los más exitosos lo harán más frecuentemente, o con mayor descendencia. Este concepto implica que en una población debe haber suficiente variabilidad genética, que se refleje en un desempeño diferente en la reproducción, y que no todos los organismos vivirán lo suficiente para dejar descendencia o reemplazarse a sí mismos. Esto quiere decir, que las poblaciones deben de reproducirse y dejar un exceso de decendencia, para poder amortiguar el efecto sobre la reproducción de aquellos organismos que no logren reproducirse con éxito. De esta manera, la sobre-producción de organismos es un requisito para que una población subsista en un intervalo prolongado de tiempo. Y la sobre-producción implica que las poblaciones tienen el potencial de crecer. La disciplina de la ecología de poblaciones, entonces, ha enfocado esfuerzos en modelar el crecimiento poblacional usando funciones matemáticas. Veremos las más básicas de ellas, con el objetivo de entender el origen y desarrollo de estos modelos. El crecimiento en dinámica de poblaciones, está enfocado en la población, y no en el individuo. Algunos aspectos fisiológicos, e individuales, pueden ser importantes a la hora de modelar el crecimiento poblacional, y estos pueden ser incluidos como parámetros del modelo; pero, en general, el interés se centra en la estimación de la cantidad de individuos (o la biomasa) que conforma una población, y cómo cambia esta cantidad con respecto al tiempo. El objetivo de los modelos de crecimiento, es obtener una función del tamaño de la población con respecto al tiempo. Existen dos aproximaciones principales para obtener esta función: la exponencial y la geométrica. El crecimiento exponencial se mide en cualquier momento en el tiempo, mientras que el crecimiento geométrico se mide a intervalos discretos. Es decir, ambos miden el crecimiento poblacional, pero una aproximación lo hace en intervalos continuos y la otra en intervalos discretos. Las otra gran categoría de modelos de crecimiento tienen que ver con la dependencia de la densidad de población. Por ejemplo, una población con suficiente espacio y recursos, puede considerarse denso-independiente, mientras que una población que está en permanente competencia intraespecífica por la adquisición de espacio y recursos, tiene un crecimiento denso-dependiente. 2.1 Crecimiento denso-independiente 2.1.1 Crecimiento geométrico Nuestra variable de interés es el tamaño poblacional, \\(N\\). Queremos conocer el crecimiento poblacional desde año 0 (\\(t=0\\)) hasta el año 1 (\\(t=1\\)). Entonces, podemos restar \\(N_1 - N_0\\) para encontrar dicho crecimiento, al que llamaremos \\(\\Delta N\\) (“Delta N”). De manera similar, podemos encontrar el crecimiento de la población en cualquier sub-intervalo de tiempo. Por ejemplo, si queremos conocer el crecimiento en el periodo \\(t=1\\) y \\(t=0.5\\), entonces nombramos este intervalo como \\(\\Delta t\\), y obtenemos el dato al dividir \\(\\Delta N / \\Delta t\\). Esta razón corresponde a la tasa de crecimiento. Una primer idea de cómo modelar la tasa de crecimiento, es pensar en que ésta equivale a la diferencia entre las entradas a la población (\\(B\\), natalidad e inmigración) menos las salidas de la población (\\(D\\), mortalidad y emigración): \\[ \\frac{\\Delta N}{\\Delta t} = B-D \\] Para conocer la tasa de crecimiento per cápita, dividimos la ecuación anterior por \\(N\\): \\[ \\frac{\\frac{\\Delta N}{\\Delta t}}{N} = \\frac{D-B}{N} \\] Si la tasa de crecimiento per cápita es mayor a cero, entonces la población crece. Si es igual a cero, la población se mantiene estable. Si es menor a cero, la población decrece. Si asumimos que la diferencia entra las entradas de la población y sus salidas son constantes, podemos arreglar la expresión anterior como \\(\\frac{E-S}{N}=\\mathrm{R_m}\\); con lo que obtenemos la forma familiar de la tasa de crecimiento: \\[\\begin{equation} \\frac{\\Delta N}{\\Delta t}=\\mathrm{R_m} N \\tag{2.1} \\end{equation}\\] Sin embargo, la ecuación (2.1) aún no está en función del tiempo, que es el objetivo que se busca. Primero empecemos por predecir La población en el año uno (\\(N_1\\)) en función del tamaño de población inicial (\\(N_0\\)). Sabemos que \\(N_1\\) será igual a \\(N_0\\) más el crecimiento poblacional durante ese intervalo de tiempo. Es decir: \\[ N_1 = N_0 + \\frac{\\Delta N}{\\Delta t} \\] Y por la ecuación (2.1), substituyendo \\(N = N_0\\), se tiene la relación: \\[\\begin{equation} \\begin{split} N_1 &amp;= N_0 + \\mathrm{R_m} N_0\\\\ &amp;= N_0 \\left( 1 + \\mathrm{R_m} \\right)\\\\ &amp;= N_0 \\lambda\\\\ \\end{split} \\end{equation}\\] Por tanto, el tamaño de población en el año uno, es igual al tamaño de población en el año cero, más el producto de la tasa de crecimiento per cápita por el tamaño de población en el año cero. Los arreglos posteriores, muestran que \\(N_1\\) depende de \\(N_0\\) y una constante \\(\\lambda = 1+\\mathrm{R_m}\\), la cual representa la tasa de multiplicación. Entonces, la población crece cuando \\(\\lambda &gt; 1\\), se mantiene estable si \\(\\lambda = 1\\), y decrece si \\(\\lambda &lt; 1\\). Ahora, podemos obtener \\(N_2\\) al saber que \\(N_2 = N_1 \\lambda\\). Observamos que \\(N_1 = N_0 \\lambda\\); por tanto, sustituimos el valor de \\(N_1\\) para acabar con \\(N_2 = N_0 \\lambda \\lambda = N_0 \\lambda^2\\). Si proseguimos de esta manera, concluimos que: \\[\\begin{equation} N_t = N_0 \\lambda^t \\tag{2.2} \\end{equation}\\] Con lo que finalmente se logra el objetivo de tener una función del tamaño poblacional en relación al tiempo. 2.1.1.1 Ejemplos Example 2.1 Graficar la ecuación (2.2) Ahora que tenemos una relación del tamaño poblacional con el tiempo, podemos crear una función sencilla para observar su comportamiento. plotGeomGrowth &lt;- function(N0, lambda, t){ vectorTiempo &lt;- 0:t vectorPoblacion &lt;- N0*lambda^vectorTiempo plot(vectorTiempo, vectorPoblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(vectorTiempo, vectorPoblacion) } plotGeomGrowth(50, 1.1, 10) Example 2.2 ¿Cuál es el \\(\\lambda\\) de una población que cuenta con 33 individuos en el año 0 (\\(t=0\\)), y que tras 10 años cuenta con 25 individuos? Grafique la curva de crecimiento. Al despejar la ecuación (2.2) para \\(\\lambda\\) se tiene \\[ \\lambda = \\left( \\frac{N_t}{N_0} \\right)^\\frac{1}{t} \\] Substituyendo los valores correspondientes se tiene que \\(\\lambda =\\) . Luego, usando la función creada en el ejemplo 2.1, y el recién calculado lambda, se grafica la curva de crecimiento. 2.1.1.2 Ejercicios Exercise 2.1 Grafique la ecuación (2.1). En el eje y la tasa de crecimiento y en el eje x el tamaño poblacional. Utilice tres valores de \\(\\mathrm{R_m}\\), uno positivo, uno igual a cero y otro negativo. El tamaño inicial de la población es de 50 individuos. \\(\\mathrm{R_m} \\in \\left[ -1, 1 \\right]\\), y \\(N \\in \\left[ 0, 50 \\right]\\). Cuál es la representación gráfica de \\(\\mathrm{R_m}\\) en el gráfico. Exercise 2.2 Grafique la ecuación (2.2). Utilice tres valores de \\(\\lambda\\), uno mayor a uno, otro igual a uno, y el último menor a 1, pero mayor a cero. El tamaño inicial de la población es de 50 individuos. Exercise 2.3 PICANTE Todo libro de lógica matemática debe contener los métodos de demostración más comunes. Utilice el metodo de inducción matemática para demostrar que la ecuación (2.2) es válida para todo \\(n \\in \\mathbb{N}\\) (números naturales). 5% sobre la nota, dividido entre el número de estudiantes que respondan el ejericio. Exercise 2.4 Si inoculo una población de bacterias en un medio de cultivo con suficiente espacio y nutrientes, con un estimado de , y tras tres horas, se estima una población de , ¿Qué valor tiene lambda? NOTA. En este caso, \\(t\\) representa una hora. Exercise 2.5 Un cultivo de células dobla su tamaño poblacional en 15 minutos (\\(\\lambda = 2\\)). Si se empieza con 1000 células, ¿cuántas de ellas existen tras 3 horas? 2.1.2 Crecimiento exponencial En la sección anterior, se trabajó con intervalos de tiempo discretos. Pero si queremos conocer el tamaño poblacional en cualquier momento del tiempo, debemos trabajar con intervalos infinitamente pequeños. Esto quiere decir que la ecuación (2.2) se escribe en su forma continua: \\[\\begin{equation} \\frac{dN}{dt}=\\mathrm{r_m} N \\tag{2.3} \\end{equation}\\] La ecuación (2.3) es una ecuación diferencial de primer orden. Este tipo particular de ecuaciones diferenciales tienen una solución analítica. Para este caso, se puede utilizar el método de separación de variables, para obtener la siguiente expresión del tamaño poblacional con respecto al tiempo (ver ejemplo 2.3): \\[\\begin{equation} N_t=N_0 e^{\\mathrm{r_m}t} \\tag{2.4} \\end{equation}\\] En la expresión anterior, \\(\\mathrm{r_m}\\) es la tasa instantánea de crecimiento, también conocida como la tasa intrínseca de crecimiento natural, o el parámetro de Malthus por Thomas Malthus. Este parámetro equivale a la diferencia entre la tasa intrínseca de nacimiento y la tasa intrínseca de mortalidad (\\(b - d\\)). La tasa intrínseca está relacionada con la tasa de multiplicación de la siguiente forma: \\[\\begin{equation*} \\begin{split} \\lambda &amp;= e^{\\mathrm{r_m}}\\\\ \\mathrm{r_m} &amp;= \\ln\\lambda\\\\ \\end{split} \\end{equation*}\\] El parámetro \\(\\mathrm{r_m}\\) tiene aplicaciones interesantes. Una de ellas es su facilidad para utilizarse en diferentes escalas de tiempo. Por ejemplo, si \\(\\mathrm{r_m} = 0.1\\) por día, y queremos escalarlo a escala semanal, procedemos a multiplicar \\(\\mathrm{r_m} = 0.1 \\times 7 = 0.7\\). Al hacer esta transformación, se debe tener en cuenta la escala de tiempo con la que se interpretan y presentan los resultados. 2.1.2.1 Ejemplos Example 2.3 Como obtener la ecuación de crecimiento exponencial (2.4) de la ecuación diferencial (2.3). El método de separación de variables consiste en dejar todos los términos de la incógnita de un lado, y los términos de la variable independiente (\\(t\\)) del otro lado de la igualdad (Barrantes Campos 2015). Entonces: \\[ \\frac{1}{N} \\times \\frac{dN}{dt}=\\mathrm{r_m} \\] Luego se integra ambos lados con respecto de la variable independiente: \\[ \\int \\left( \\frac{1}{N} \\times \\frac{dN}{dt}\\right)\\,dt=\\int \\mathrm{r_m}\\,dt \\] Observe que del lado izquierdo los diferenciales se cancelan: \\[\\begin{equation*} \\begin{split} \\int \\frac{dN}{N}&amp;=\\mathrm{r_m} t + c\\\\ \\ln N &amp; = \\mathrm{r_m} t + c\\\\ \\end{split} \\end{equation*}\\] Se despeja \\(N\\), y se obtiene \\(N=Ce^{\\mathrm{r_m} t}\\). Luego, cuando \\(N=N_0\\) entonces \\(t=0\\); por lo que la expresión se simplifica a \\(N_0 = C e^0 = C\\). Dando como resultado la expresión \\[ N = N_0 e^{\\mathrm{r_m} t} \\] Example 2.4 De acuerdo con Illman, Scragg, and Shales (2000) un gramo de Chlorella emersonii puede contener (energía por gramo). Si la tasa intrínseca es de , ¿cuántos gramos de Chlorella necesito para producir ? ¿Cuál es el tiempo de producción? Asuma un crecimiento exponencial, y un inóculo inicial con \\(N_0 = 1\\mu \\si{\\gram}\\) de Chlorella. En este caso, pensamos en el tamaño poblacional como biomasa, en lugar del número de individuos. El primer paso es calcular \\(N\\) para producir la cantidad deseada de energía, lo cual resolvemos con una simple conversión para obtener: \\[ N=\\frac{1\\si{\\gram}}{29\\cancel{\\si{\\kilo\\joule}}}\\times 5000 \\cancel{\\si{\\kilo\\joule}}=172.4138\\si{\\gram} \\] Luego, despejamos \\(t\\) de la ecuación (2.4): \\[ t = \\ln \\left(\\frac{N}{N_0}\\right)\\mathrm{r_m}^{-1} \\] Se hacen las sustituciones correspondientes: \\(\\mathrm{r_m} = 0.99\\), \\(N_0 = \\SI{1e-6}{\\gram}\\), \\(N = \\SI{172.414}{\\gram}\\), y se obtiene que el tiempo necesario para obtener una biomasa equivalente a una energía de 5000 kilojoule es \\(t =\\) . 2.1.2.2 Ejercicios Exercise 2.6 Si \\(\\lambda = 1.027\\) por semana. Escale \\(\\lambda\\) de semanas a meses (1 mes = 4 semanas). Utilice la relación de \\(\\lambda = e^{\\mathrm{r_m}}\\). Exercise 2.7 Para los siguentes escenarios de la ecuación (2.4): \\(\\mathrm{r_m}\\) negativo. \\(\\mathrm{r_m}\\) igual a cero. \\(\\mathrm{r_m}\\) positivo. Obtenga el límite: \\[ \\lim_{t \\to \\infty } N(t) \\] Dé una interpretación de los resultados, en términos de la población. Exercise 2.8 Demuestre, utilizando un razonamiento deductivo, que si \\(\\mathrm{R_m} &lt; 0\\), la población decrece. Puede usar los resultados del ejercicio 2.7. Exercise 2.9 Analice biológicamente el significado del resultado del ejercicio 2.7, cuando \\(\\mathrm{r_m}\\) es positivo. 2.2 Crecimiento denso-dependiente 2.2.1 Crecimiento logístico Nuestros dos modelos básicos funcionan en condiciones controladas, cuando el espacio y los recursos no son limitantes para el crecimiento. Sin embargo, esto no es lo que se observa en poblaciones silvestres, donde tras el periodo de crecimiento exponencial, sigue una disminución en la velocidad del crecimiento, hasta que llega a ser cero, o incluso negativo (decrecimiento). Pueden existir varios mecanismos de regulación del crecimiento. Entre ellos existe la competencia intraespecífica, la competencia interespecífica, la depredación, entre otros. Algunas razones para la desaceleración del crecimiento pueden estar relacionadas a la tasa de consumo de alimento, frente a la tasa de producción. En este caso, cuando la tasa de consumo iguala a la tasa de producción, la población pierde el potencial de crecer. Los individuos empiezan a competir, puede haber emigración, mortalidad, etc. Independientemente de las razones que causen la disminución del crecimiento, podemos entender que la tasa intrínseca de crecimiento (\\(r_m\\)), en realidad no es una constante como en el modelo de crecimiento exponencial (Figura ??); más bien, es una función del tamaño de población, \\(N\\) (Figura ??). \\[ r_m = f \\left( N_t \\right) \\] Esta función debe tener algunas características particulares. Por ejemplo, debe ser máxima cuando el tamaño de población es pequeño, asumiendo que en ese momento hay muchos recursos y espacio para todos los individuos. Por otro lado, cuando la población alcanza un tamaño grande, la tasa de crecimiento debe disminuir hasta llegar a cero. Debemos introducir un nuevo término a nuestro modelo de crecimiento, para cumplir con las características descritas arriba. Este término es la capacidad de carga, \\(K\\), que es el punto donde la tasa de crecimiento se vuelve cero. Una expresión que cumple con estos requerimientos es: \\[ r_m = \\mathrm{r_m}\\left(1-\\frac{N_t}{K}\\right) \\] Podemos observar el comportamiento de \\(r_m\\) con un gráfico. rm &lt;- 1 K &lt;- 100 N &lt;- 0:100 val &lt;- rm * (1 - (N / K)) plot(N, val, type = &quot;l&quot;, las = 1, lwd = 2, xlab = &quot;Tamaño de población&quot;, ylab = expression(r[m]) ) Si ahora sustituimos la versión denso-dependiente de \\(r_m\\) en la ecuación (2.4), obtenemos \\[\\begin{equation} \\frac{dN}{dt}=\\mathrm{r_m}\\left(1-\\frac{N_t}{K}\\right)N_t \\tag{2.5} \\end{equation}\\] Esta ecuación diferencial también puede resolverse por el método de separación de variables (ver Ejemplo 2.3). Una vez resuelta, la expresión en función del tiempo es: \\[\\begin{equation} N_t=\\frac{K\\,N_0 e^{rt} }{N_0 e^{rt} - N_0+K} = \\frac{K}{1 + \\left( \\frac{K}{N_0} - 1 \\right) e^{-rt}} \\tag{2.6} \\end{equation}\\] r &lt;- 0.4 K &lt;- 100 N0 &lt;- 10 curve( (K*N0*exp(r*x))/(N0*exp(r*x)-N0+K), from = 0,to = 20, las = 1, lwd = 2, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de Población&quot;) Figure 2.1: Crecimiento logístico, con capacidad de carga igual a cien individuos Observamos que la población ya no crece de manera indefinida. Ahora tiene un tope superior igual a la capacidad de carga, \\(K\\). Técnicamente, decimos que existe un límite asintótico al crecimiento; ya que, el tamaño de población tiende a \\(K\\), pero nunca llega a alcanzarlo (pero ver ejercicio 2.11). Por otro lado, observamos que la población crece rápidamente al inicio; pero, al final de la curva el crecimiento se detiene. Esto implica que en algún punto, el crecimiento alcanza un máximo. Este punto se conoce como el punto de inflexión. De cálculo diferencial, sabemos que los puntos de inflexión se obtienen al igualar la segunda derivada de la función a cero: \\[ \\frac{d^2N}{dt^2}=\\frac{d(dN)}{d(dt)}=0 \\] Sabemos que la primer derivada de \\(N_t\\) corresponde a la ecuación (2.5). Entonces, para encontrar el punto de inflexión, primero debemos encontrar: \\[ \\frac{d^2N}{dt^2}=\\frac{d(dN)}{d(dt)}=D\\left[ \\mathrm{r_m}N_t\\left(1-\\frac{N_t}{K}\\right)\\right]=0 \\] Se utiliza la regla del producto, y se tiene: \\[ D\\left[ \\mathrm{r_m}N_t \\right]\\left(1-\\frac{N_t}{K}\\right) + \\mathrm{r_m}N_t\\; D\\left[\\left(1-\\frac{N_t}{K}\\right)\\right]=0 \\] Al resolver las derivadas se obtiene: \\[ N = \\frac{K}{2} \\] Quiere decir, que el mayor crecimiento se obtiene cuando el tamaño de población es igual a la mitad de la capacidad de carga. Si sustituimos \\(N = K/2\\) en la ecuación (2.5), tenemos que el crecimiento máximo de una población es: \\[ \\left. \\frac{dN}{dt}\\right|_{N = K/2} = \\frac{\\mathrm{r_m}K}{4} \\] Esto tiene grandes implicaciones en el manejo de recursos naturales. Es la base de los modelos de producción excedentaria. En pesquerías, a este número se le conoce como Máximo Rendimiento Sostenible; sin embargo, ha sido fuertemente criticado (Larkin 1977), y en la actualidad se utilizan algunas variantes de esta cantidad, o otros modelos más apropiados, basados en estructura de edades o tallas. 2.2.2 Usos del modelo logístico En la sección anterior calculamos el Máximo Rendimiento Sostenible (MRS). Ahora lo definiremos como: El crecimiento máxmimo que una población puede producir, bajo una capacidad de carga determinada. El principio detrás de utilizar el MRS como un parámetro de manejo, es que: *esta es la cantidad máxima de individuos, o biomasa, que se puede extraer de una población, sin provocar un crecimiento negativo. Recordando que: Tamaño de población = Tamaño anterior + Crecimiento La idea de cosechar una población se fundamente en que si se extrae una cantidad igual al crecimiento de la población, la biomasa restante logrará regenerarse y crecer. La idea del MRS, es que el tamaño de una población cosechada, debe llevarse a \\(N/2\\), para poder aprovechar el crecimiento máximo que puede generar dicha población. Exercise 2.10 PICANTE Use el método de separación de variables para resolver la ecuación (2.5). 5% sobre la nota, dividido entre el número de estudiantes que respondan el ejercicio Exercise 2.11 Demuestre que la población no crecerá más cuando llega a la capacidad de carga. Es decir, tome el límite de la ecuación (2.5), cuando \\(t \\to \\infty\\). 2.2.3 Matrices COMADRE COMADRE DATA Ojo a la guia de usuario 2.3 Otras fuentes bibliográficas Esta sección está basada en los capítulos 4 y 5 de Neal (2004). En la sección 2.3 de Berryman and Kindlmann (2008), se desarrollan los mismos modelos básicos vistos aquí; en este mismo libro se presenta una buena introducción sobre la ecología de poblaciones como sistemas, en el capítulo 1. References "],
["soluciones-a-los-ejercicios.html", "Capítulo 3 Soluciones a los ejercicios", " Capítulo 3 Soluciones a los ejercicios Ejercicio 2.1 plot(0,0,xlim = c(0,50), ylim = c(0,100) , type = &#39;n&#39;,xlab = &#39;Tamaño poblacional&#39;, ylab = &quot;Tasa de crecimiento&quot;) val=numeric() for(Rm in c(-1,0,1)){ abline(50,Rm,lty=Rm+2) val=append(val,Rm) } legend(&quot;topleft&quot;,lty= 1:3,legend = paste(&#39;Rm = &#39;,val)) \\(R_m\\) representa la pendiente de la recta. Ejercicio 2.5 En 3 horas existen 12 periodos de 15 minutos (\\(t=12\\)). Entonces aplicamos la ecuación (2.2): \\[ 100\\times 2^{12} = \\num{409600}\\text{ células} \\] Ejercicio 2.6 Obtener \\(r_m = \\ln \\lambda\\); luego multiplicar \\(r_{mes}=r_m \\times 4\\) para obtener la escala a meses. Finalmente, transformar \\(\\lambda_{mes}=e^{r_{mes}}\\). Ejercicio 2.8 Asumimos que \\(r_m\\) es cualquier constante positiva (\\(r_m \\in \\mathbb{R}^+\\)). Entonces \\(-1\\times r_m \\in \\mathbb{R}^-\\). Luego, tomamos el límite: \\[ \\lim_{t \\to \\infty}N_0 e^{-r_m t} \\] Que equivale a: \\[ \\lim_{t \\to \\infty}\\frac{N_0}{e^{r_m t}} \\] Vemos que el denominador de la expresión anterior es un número que crecerá infinitamente. Si reemplazamos \\(e^{r_m t}\\) por \\(x\\), cuando \\(t \\to \\infty \\Rightarrow x \\to \\infty\\). Y quedamos con la expresión: \\[ \\lim_{x \\to \\infty}\\frac{N_0}{x} = 0 \\] Porque cuando \\(x \\to \\infty \\Rightarrow x \\gg N_0\\). Es decir, cuando \\(x\\) se vuelve infinito, es mucho más grande que \\(N_0\\), por tanto, el cociente tiende a cero, cuando \\(x\\) tiende a infinito. Poblacionalmente, esto significa, que si una población mantiene una tasa intrínseca negativa, por un periodo de tiempo suficientemente largo, sufrirá un evento de extinción. "],
["metodos-numericos-para-ecologia-de-poblaciones.html", "A Métodos numéricos para ecología de poblaciones A.1 Simulación de ecuaciones diferenciales", " A Métodos numéricos para ecología de poblaciones A.1 Simulación de ecuaciones diferenciales Tomaremos el ejemplo de la ecuación (2.3), para mostrar un método para encontrar el tamaño de población, sin tener que utilizar cálculo (Barrantes Campos 2015). Este es el método de Euler, que se explicará mediante un ejemplo. Una derivada implica un cambio infinitesimal de una variable en relación a otra. Por ejemplo, el cambio en el número de individuos de una población en un momento pequeñísimo de tiempo, puede representarse como la diferencia de la población, entre la duración de ese pequeño intervalo de tiempo: \\[ \\frac{dN}{dt} \\approx \\frac{\\Delta N}{\\Delta t} = \\frac{N_t - N_{t-\\Delta t}}{\\Delta t} \\] Si sustituimos en la ecuación (2.4), tenemos: \\[ \\frac{N_t - N_{t-\\Delta t}}{\\Delta t} = r_m N \\] Arreglando la expresión anterior, podemos despejar en terminos de \\(N_t\\): \\[ N_t= N_{t-\\Delta t} + r_m N_{t-\\Delta t} \\Delta t \\] Hay que resaltar que esta no es una solución exacta; sino, una aproximación. Entre más pequeño se haga \\(\\Delta t\\), más se aproximará el resultado, al valor exacto dado por (2.4). En casos donde no existe una solución analítica, o simplemente, no es sencillo resolver la ecuación, siempre se puede recurrir a los métodos numéricos, para tener una idea de la solución real. Para programar este sencillo ejemplo, necesitamos varios pasos: Definir un valor inicial de la población, y el valor de \\(t\\) en el cuál queremos conocer el tamaño de población. Definir el Valor de \\(r_m\\). Establecer un criterio para guardar el valor de \\(N_t\\), cada cierto lapso de tiempo. (Para no crear un objeto virtual innecesariamente grande) Crear un objeto para guardar el tamaño de la población, y los puntos de tiempo a los que está asociada. Definir el tamaño de \\(\\Delta t\\), y calcular el número de iteraciones necesarias hasta llegar al final del periodo de tiempo de interés. Crear un bucle, y ejecutar iteractivamente la integración de Euler. Definir un criterio para detener el algoritmo. El siguiente algoritmo generaliza todas las funciones dependientes de \\(N_{t-\\Delta t}\\). \\[ N_t= N_{t-\\Delta t} + f \\left( N_{t-\\Delta t},\\mathbf{c} \\right) \\Delta t \\] Donde \\(\\mathbf{c}\\) son constantes. euler &lt;- function(fooName, valInic, tiempoParar, deltaT,guardarCada,...){ arg &lt;- list(...) fn &lt;- get(fooName) #Encuentra los argumentos provistos argName &lt;- match.arg(names(arg),#arg provistos formalArgs(fn),#arg existentes several.ok = TRUE) #Nombra la lista con los nombres de los argumentos provistos names(arg) &lt;- argName val &lt;- numeric() val[1] &lt;- valInic valTmp &lt;- numeric() valTmp &lt;- val[1] #Completa la lista de argumentos con N[t-1] arg[[ (length(arg)+1) ]] &lt;- valInic totalArg &lt;- length(arg) #Escribe todos los nomres de los argumentos, para do.call names(arg) &lt;- formalArgs(fn)#Encuetra los nombres de los argumentos tiempo &lt;- numeric() tNow &lt;- 0 tiempo[1] &lt;- 0 while( tNow &lt; tiempoParar ){ valTmp &lt;- valTmp + do.call(fn,args = arg)*deltaT tNow &lt;- tNow + deltaT if( tNow%%guardarCada &lt;=deltaT ){ val &lt;- append(x = val,values = valTmp) tiempo &lt;- append(x = tiempo, values = tNow) arg[[totalArg]] &lt;- valTmp } } return( list( poblacion = val, tiempo = tiempo, tNow = tNow, arg = arg ) ) } Por ejemplo diffG1 &lt;- function(rm, N) N * rm N0 &lt;- 10 Resultados1 &lt;- euler(fooName = &quot;diffG1&quot;, valInic = N0, tiempoParar = 10, deltaT = 1/100, guardarCada = 1, rm = 0.22) diffG2 &lt;- function(rm, Kmax, N) rm * (1 - N/Kmax) N0 &lt;- 10 Resultados2 &lt;- euler(fooName = &quot;diffG2&quot;, valInic = N0, tiempoParar = 50, deltaT = 1/100, guardarCada = 1, rm = 1.92, Kmax = 60) plot(Resultados1$tiempo, Resultados1$poblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(Resultados1$tiempo, Resultados1$poblacion) plot(Resultados2$tiempo, Resultados2$poblacion, type = &quot;p&quot;, xlab = &quot;Tiempo&quot;, ylab = &quot;Tamaño de población&quot;, las = 1, pch = 21, bg = 1) lines(Resultados2$tiempo, Resultados2$poblacion) References "],
["tutorial-de-r-con-rstudio.html", "B Tutorial de R con RStudio B.1 Crear un proyecto en RStudio B.2 Funciones básicas en R B.3 Estructuras de datos B.4 Funciones", " B Tutorial de R con RStudio B.1 Crear un proyecto en RStudio Crear un proyecto en RStudio para cualquier proyecto con R, es importante. Los proyectos organizan los documentos en una sola carpeta, y son fundamentales para el control de versión con un software como Git. Abrimos RStudio, y ubicamos la barra de herramientas en la parte superior. El primer paso es ir a file --&gt; New Project. Creamos una carpeta en una ubicación que nos permita tener derechos de administrador, e idealmente, fuera de cualquier carpeta de sincronización en línea. RStudio nos guiará por los siguientes pasos: Crear un Proyecto: Escogemos que sea un nuevo directorio. Tipo de Proyecto: Escogemos nuevo proyecto. Crear: Escogemos la carpeta, y el nombre del proyecto. NO marcamos crear repositorio con Git. Figure B.1: Cómo hacer un nuevo proyecto, en . Volvemos a la barra de herramientas, en RStudio, y vamos a File --&gt; New file --&gt; R script. Este archivo solo soporta código en R, con la gran ventaja de que colorea las funciones, variables y estructuras más comunes; lo cual, hace que el código sea más legible. IMPORTANTE: En el siguiente tutorial, el código en R se encuentra dentro de ambientes especiales, rodeados por una caja gris. Escribe las líneas que se muestran en esa caja, y para ver el resultado en la consola de R, apreta Ctrl + ENTER. B.2 Funciones básicas en R Ahora que hemos creado un proyecto, y tenemos un lienzo en blanco, empezamos por ver las funciones más elementales. R contiene todas las operaciones básicas como: adición, substracción, multipliación, división, potencias, y logaritmos. # Tras cada línea presiona Ctrl + ENTER 1 + 1 # adición 1-1 # substracción 1*2 # multiplicación 1/2 # división 2^(8) #potencia log(2) # logaritmo natural log10(2) #logaritmo base 10 log(x = 2, base = &lt;n&gt;) #logaritmo base &lt;n&gt;, donde &lt;n&gt; se # reemplaza por cualquier número. Notar que en el código, cualquier línea de texto precedida de # es un comentario, que no será evaluado por el computador. Agregar comentarios es muy útil, si uno va a re-utilizar parte del código en otro momento. Ayuda a mantener la claridad en lo que se está haciendo. Continuando con las operaciones básicas, también podemos mezclar operaciones de la forma que convenga. Siempre considerando las reglas de prioridad por paréntesis. Por ejemplo, si queremos calcular el logaritmo del resultado de una función, para una base 16. log( x= 1 / (1 + (5/2) ) , base = 16 ) Luego, como la mayoría de lenguajes de programación, podemos asignar valores a un objeto y utilizarlo después en otra operación: a &lt;- log10(4/3) # &#39;a&#39; tiene el valor de la operación b &lt;- a^2 # Equivale a log10(4/3)^2 c &lt;- b^2 - a c Esto quiere decir que podemos crear un objeto con el operador &lt;-, que pueden ser datos, o resultados de otras operaciones, para incluirlo en una nueva función. Por lo que la salida de una función puede ser la entrada de la próxima. Figure B.2: Flujo de entradas y salidas en una función de B.3 Estructuras de datos R puede manejar objetos muy complejos; sin embargo, estos objetos generalmente se componen de partes muy sencillas. Revisaremos éstas partes sencillas, y luego crearemos un objeto más complejo. Vectores Un vector en programación, es una colección de uno o más valores. Podemos pensar que un vector en R equivale a una matriz de \\(n\\) filas, y solo una columna. vect1 &lt;- c(1,2,3,4,5,6,7,8,9,0) #es una concatenación de # números, que se crea con la función &#39;c(...)&#39; vect2 &lt;- rnorm(10) # son diez números al azar obtenidas # de una distribución normal estándar Los elementos de un vector pueden ser llamados utilizando un sub-índice. Éste inicia en 1, hasta \\(n\\). Donde \\(n\\) es la cantidad de elementos en un vector. vect1[3] También es posible llamar varios elementos a la vez, si el subíndice del vector es otro vector. vect1[c(3,4,5)] vect1[3:5] # 3:5 crea una secuencia de enteros, que incrementa en 1 a la vez. vect1[rep(5,times=10)] # rep, es una función que repite un #número un determinado número de veces. Los vectores pueden ser datos en un archivo externo, o resultado de funciones u operaciones. A diferencia de otros lenguajes R, maneja vectores de una forma más intuitiva. vec3 &lt;- vec1 + vec2 # es un nuevo vector basado en la adición de los dos primeros. Matrices Las matrices son un arreglo de datos en dos dimensiones, es decir, filas y columnas. Por covención, cuando decimos que una matriz es de tamaño \\(f\\times c\\), nos referimos a que tiene \\(f\\) filas, y \\(c\\) columnas. Las filas siempre se nombran primero que las columnas. (m1 &lt;- matrix(1:9, ncol=3, byrow = T) ) (m2 &lt;- matrix(1:9, ncol=3, byrow = F) ) Los elementos de una matriz se llaman por la combinación de filas y columnas a la que corresponde. Del ejemplo anterior, si quisiéramos obtener el elemento central de la matriz m1, lo llamamos así m1[2,2]. Si quisiéramos llamar toda la primer columna, entonces escribimos m1[,1]. O la primer y tercer fila m1[c(1,3),]. Las operaciones con matrices suelen ser más delicadas y existen operadores específicos para ellas. Marco de datos o Data frames Esta estructura es similar a una matriz, con la diferencia, que algunas de sus columnas pueden contener factores, y no solo valores numéricos. Estas son las estructuras con las que representamos un diseño experimental, por ejemplo: ## Var1 Var2 z ## 1 T1 a -0.9984820 ## 2 T2 a 0.3368565 ## 3 T1 b -0.1197414 ## 4 T2 b -1.0552649 ## 5 T1 c 0.6542564 ## 6 T2 c 1.3707045 Arreglos o arrays Estos son matrices de 3 o más dimensiones. Por ejemplo, si tenemos una serie de fotografías con la misma resolución, en el mismo lugar, podemos representar los pixeles como una matriz \\(f\\times c\\), y el tiempo como una dimensión adicional. Si ponemos en rápida sucesión las matrices, tendremos un video o película. array(1:(6*2),dim=(c(2,3,2))) Listas Las listas son colecciones de cualquiera de los objetos anteriores (y otros que no hemos visto). l1 &lt;- list( vector = vect1, matriz = m1 ) Podemos llamar a los elementos de una lista, de dos formas: si conocemos el orden de los elementos de la lista, entonces, escribimos el índice dentro de dos pares de corchetes rectos: l1[[1]], para llamar el vector y l1[[2]], para llamar la matriz. Si conocemos los nombres de los elementos de la lista, usamos la siguiente forma: l1$vector, para el vector; y l1$matriz, para la matriz. Una vez dentro del objeto de la lista, podemos llamar sus elementos de manera tradicional. Por ejemplo, l1$matriz[2,2], para llamar el elemento central de la matriz dentro de la lista. B.4 Funciones Las funciones se representan por un nombre, seguido de un paréntesis redondo. Todo lo que esté dentro de ese paréntesis son sus argumentos. Para finalizar la función, cerramos con un paréntesis redondo derecho: funcion(argumento1 = valor1, argumento2 = valor 2) Nosotros podemos crear nuestras propias funciones en R. El procedimiento es sencillo: Llamamos a la función con un nombre, y declaramos que se trata de una función Nombramos los argumentos de la función. Podemos asignar valores por defecto. Los argumentos deben ir entre paréntesis redondos. Escribimos el cuerpo de la función entre paréntesis tipo llave {}. El cuerpo de la función debe terminar con un solo objeto que será retornado como salida del proceso. Por ejemplo, si queremos hacer nuestra propia función para calcular un promedio. Primero debemos entender la fórmula subyacente: \\[ \\bar{x}= \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Es decir, sumamos todos los elementos de un vector de valores, y lo dividimos por el tamaño del vector. Entonces, nuestro argumento será un vector, y nuestra salida, un valor único con el promedio. promedio &lt;- function(vectorX){ sumaX &lt;- sum(vectorX) n &lt;- length(vectorX) #length(), es una función que calcula # el tamaño del vector. valor &lt;- sumaX / n return(valor) } # Ahora probamos la función, tomando el promedio de un # vector de números normales con media igual a cero # Esperamos, que nuestro promedio sea un valor cercano # a cero. valores &lt;- rnorm(100) (promedio(valores)) ## [1] 0.1281167 "],
["asignaciones.html", "C Asignaciones C.1 Tarea 01: ¡Hola mundo con Rmarkdown! C.2 Tarea 02: Ejercicios de crecimiento", " C Asignaciones C.1 Tarea 01: ¡Hola mundo con Rmarkdown! Objetivo: Verificar que el estudiante ha instalado, y maneja el ambiente de trabajo que se utilizará durante el curso. Primero revisa los enlaces provistos en el wiki. Actividades Haz un nuevo proyecto en RStudio, que se llame Tarea01. Ver pasos en sección B.1. En la consola de R, escribe install.packages(rmarkdown), con todas las dependencias. O instala el paquete desde RStudio como se mostró en el wiki. En RStudio File--&gt; New File --&gt; R Markdown. Crea una sección principal que se llame Información profesional. Luego, crea una sección secundaria que se llame Intereses. Usa bullets para nombrar algunos intereses profesionales. Luego, crea una sección secundaria llamada Experiencia Laboral, si aplica. Nombra algunos trabajos relacionados con el curso de Ecología de Poblaciones. Crea una sección principal que se llame Integración con R Consigue algunos datos interesantes en internet. Deben ser datos para graficar, por tanto deben tener dos columnas, y varias filas. Puedes ir a Wolfram Alpha. Guarda los datos como un texto delimitado por comas (.csv). En R o RStudio corre el comando ?read.table. Para correr un comando en RStudio apreta Cntrl + R. Crea un “chunk” de código. Esto se hace en RStudio, busca un botón en la barra especial de rmarkdown que diga insert, luego escoge R. Lee la tabla y asignala a un objeto: datos &lt;- read.table(&lt;ruta_de_archivo_en_comillas&gt;, header = TRUE, sep = &quot;,&quot;) Grafica los datos en un nuevo “chunk”. Usa el método que prefieras. Hay mucho material de cómo hacer gráficos en R. Por ahora, un gráfico básico es suficiente. Ahora, haz otra sección llamada Bibliografía. En un párrafo escribe una mini-revisión de algún tema que domines y del que dispongas referencias bibliográficas. Usa los mecanismos de citas de rmarkdown Cita en texto con @citationKey Cita en paréntesis con [@citationKey] Importante: Para que las citas funcionen, debes agregar unas opciones en la cabecera del documento (YAML header): bibliography: &lt;tu_archivo_bib&gt;.bib csl: apa.csl El archivo apa.csl se puede encontrar en google. Es un archivo de estilo APA, para dar formato a la bibliografía. Revisa el repositorio de CSL de Zotero, en busca de las revistas disponibles. Por último, corre el documento con el botón knit. Envía el documento .Rmd y el .pdf al profesor (dawidh15@gmail.com). C.2 Tarea 02: Ejercicios de crecimiento Se recomienda hacer primero todo en papel, y luego pasarlo en limpio usando Rmarkdown. LINKS para LatexMath Exercise C.1 Resuelva el siguiente ejercicio de crecimiento exponencial En un laboratorio se cultiva una especie presa para un programa de reintroducción de una especie de pez. En el laboratorio, se inició un proyecto de mejora en la producción de la presa, y se ha diseñado un experimento para aumentar el valor nutricional de las presas. Se cuenta con un presupuesto de para la producción de animales presa en el proyecto. Además, el diseño experimental requiere de 40 recipientes acondicionados con diferentes tratamientos. Las presas crecen con una tasa de crecimiento intrínseco de . Además, el inóculo inicial es de individuos por recipiente. Si se sabe que el costo de mantenimiento por organismo-día es de : ¿Cuántos organismos por recipiente se pueden cultivar sin sobrepasar el dinero disponible? ¿Cuánto tiempo, en días, se necesitan para alcanzar esa cantidad? Tips: Este es un problema de mínimos. Primero hay que buscar la función a minimizar. Luego, uno encuentra el valor apropiado del parámetro de interés cuando la función se minimiza. Para minimizar una diferencia, use el valor absoluto de la diferencia: \\(\\left| x - y\\right|\\). Use la función optim o optimize. Una vez que tenga la función que desea minimizar escrita en R use este código: out &lt;- optim(par = 0,fn = &lt;nombre_de_funcion_para_minimizar&gt;, control = list(reltol=0.01), method = &quot;Brent&quot;, lower = &lt;numero&gt;, upper = &lt;numero&gt;) Antes se recomienda buscar la ayuda de la función en la consola de R, al escribir ?optim. Revise los ejemplos, y lea detalladamente la ayuda. "]
]
